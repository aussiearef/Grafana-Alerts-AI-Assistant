{"version":3,"file":"live.mjs","sources":["../../../src/types/live.ts"],"sourcesContent":["/**\n * The channel id is defined as:\n *\n *   ${scope}/${namespace}/${path}\n *\n * The scope drives how the namespace is used and controlled\n *\n * @alpha\n */\nexport enum LiveChannelScope {\n  DataSource = 'ds', // namespace = data source ID\n  Plugin = 'plugin', // namespace = plugin name (singleton works for apps too)\n  Grafana = 'grafana', // namespace = feature\n  Stream = 'stream', // namespace = id for the managed data stream\n}\n\n/**\n * The type of data to expect in a given channel\n *\n * @alpha\n */\nexport enum LiveChannelType {\n  DataStream = 'stream', // each message contains a batch of rows that will be appended to previous values\n  DataFrame = 'frame', // each message is an entire data frame and should *replace* previous content\n  JSON = 'json', // arbitrary json message\n}\n\nexport enum LiveChannelConnectionState {\n  /** The connection is not yet established */\n  Pending = 'pending',\n  /** Connected to the channel */\n  Connected = 'connected',\n  /** Connecting to a channel */\n  Connecting = 'connecting',\n  /** Disconnected from the channel.  The channel will reconnect when possible */\n  Disconnected = 'disconnected',\n  /** Was at some point connected, and will not try to reconnect */\n  Shutdown = 'shutdown',\n  /** Channel configuration was invalid and will not connect */\n  Invalid = 'invalid',\n}\n\nexport enum LiveChannelEventType {\n  Status = 'status',\n  Join = 'join',\n  Leave = 'leave',\n  Message = 'message',\n}\n\n/**\n * @alpha -- experimental\n */\nexport interface LiveChannelStatusEvent {\n  type: LiveChannelEventType.Status;\n\n  /**\n   * {scope}/{namespace}/{path}\n   */\n  id: string;\n\n  /**\n   * unix millies timestamp for the last status change\n   */\n  timestamp: number;\n\n  /**\n   * flag if the channel is actively connected to the channel.\n   * This may be false while the connections get established or if the network is lost\n   * As long as the `shutdown` flag is not set, the connection will try to reestablish\n   */\n  state: LiveChannelConnectionState;\n\n  /**\n   * When joining a channel, there may be an initial packet in the subscribe method\n   */\n  message?: any;\n\n  /**\n   * The last error.\n   *\n   * This will remain in the status until a new message is successfully received from the channel\n   */\n  error?: any;\n}\n\nexport interface LiveChannelJoinEvent {\n  type: LiveChannelEventType.Join;\n  user: any; // @alpha -- experimental -- will be filled in when we improve the UI\n}\n\nexport interface LiveChannelLeaveEvent {\n  type: LiveChannelEventType.Leave;\n  user: any; // @alpha -- experimental -- will be filled in when we improve the UI\n}\n\nexport interface LiveChannelMessageEvent<T> {\n  type: LiveChannelEventType.Message;\n  message: T;\n}\n\nexport type LiveChannelEvent<T = any> =\n  | LiveChannelStatusEvent\n  | LiveChannelJoinEvent\n  | LiveChannelLeaveEvent\n  | LiveChannelMessageEvent<T>;\n\nexport function isLiveChannelStatusEvent<T>(evt: LiveChannelEvent<T>): evt is LiveChannelStatusEvent {\n  return evt.type === LiveChannelEventType.Status;\n}\n\nexport function isLiveChannelJoinEvent<T>(evt: LiveChannelEvent<T>): evt is LiveChannelJoinEvent {\n  return evt.type === LiveChannelEventType.Join;\n}\n\nexport function isLiveChannelLeaveEvent<T>(evt: LiveChannelEvent<T>): evt is LiveChannelLeaveEvent {\n  return evt.type === LiveChannelEventType.Leave;\n}\n\nexport function isLiveChannelMessageEvent<T>(evt: LiveChannelEvent<T>): evt is LiveChannelMessageEvent<T> {\n  return evt.type === LiveChannelEventType.Message;\n}\n\n/**\n * @alpha -- experimental\n */\nexport interface LiveChannelPresenceStatus {\n  users: any; // @alpha -- experimental -- will be filled in when we improve the UI\n}\n\n/**\n * @alpha -- experimental\n */\nexport type LiveChannelId = string;\n\n/**\n * @alpha -- experimental\n */\nexport interface LiveChannelAddress {\n  scope: LiveChannelScope;\n  namespace: string; // depends on the scope\n  path: string;\n\n  /**\n   * Additional metadata passed to a channel.  The backend will propagate this JSON object to\n   * each OnSubscribe and RunStream calls.  This value should be constant across multiple requests\n   * to the same channel path\n   */\n  data?: any;\n}\n\n/**\n * Return an address from a string\n *\n * @alpha -- experimental\n */\nexport function parseLiveChannelAddress(id?: string): LiveChannelAddress | undefined {\n  if (id?.length) {\n    let parts = id.trim().split('/');\n    if (parts.length >= 3) {\n      return {\n        scope: parts[0] as LiveChannelScope,\n        namespace: parts[1],\n        path: parts.slice(2).join('/'),\n      };\n    }\n  }\n  return undefined;\n}\n\n/**\n * Check if the address has a scope, namespace, and path\n *\n * @alpha -- experimental\n */\nexport function isValidLiveChannelAddress(addr?: LiveChannelAddress): addr is LiveChannelAddress {\n  return !!(addr?.path && addr.namespace && addr.scope);\n}\n\n/**\n * Convert the address to an explicit channel path\n *\n * @alpha -- experimental\n */\nexport function toLiveChannelId(addr: LiveChannelAddress): LiveChannelId {\n  if (!addr.scope) {\n    return '';\n  }\n  let id: string = addr.scope;\n  if (!addr.namespace) {\n    return id;\n  }\n  id += '/' + addr.namespace;\n  if (!addr.path) {\n    return id;\n  }\n  return id + '/' + addr.path;\n}\n"],"names":["LiveChannelScope","LiveChannelType","LiveChannelConnectionState","LiveChannelEventType"],"mappings":"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"}