{"version":3,"file":"reduce.mjs","sources":["../../../../src/transformations/transformers/reduce.ts"],"sourcesContent":["import { map } from 'rxjs/operators';\n\nimport { guessFieldTypeForField } from '../../dataframe/processDataFrame';\nimport { getFieldDisplayName } from '../../field/fieldState';\nimport { KeyValue } from '../../types/data';\nimport { DataFrame, Field, FieldType } from '../../types/dataFrame';\nimport { DataTransformerInfo, FieldMatcher, MatcherConfig } from '../../types/transformations';\nimport { fieldReducers, reduceField, ReducerID } from '../fieldReducer';\nimport { getFieldMatcher } from '../matchers';\nimport { alwaysFieldMatcher, notTimeFieldMatcher } from '../matchers/predicates';\n\nimport { DataTransformerID } from './ids';\n\nexport enum ReduceTransformerMode {\n  SeriesToRows = 'seriesToRows', // default\n  ReduceFields = 'reduceFields', // same structure, add additional row for each type\n}\n\nexport interface ReduceTransformerOptions {\n  reducers: ReducerID[];\n  fields?: MatcherConfig; // Assume all fields\n  mode?: ReduceTransformerMode;\n  includeTimeField?: boolean;\n  labelsToFields?: boolean;\n}\n\nexport const reduceTransformer: DataTransformerInfo<ReduceTransformerOptions> = {\n  id: DataTransformerID.reduce,\n  name: 'Reduce',\n  description: 'Reduce all rows or data points to a single value using a function like max, min, mean or last.',\n  defaultOptions: {\n    reducers: [ReducerID.max],\n  },\n\n  /**\n   * Return a modified copy of the series. If the transform is not or should not\n   * be applied, just return the input series\n   */\n  operator: (options) => (source) =>\n    source.pipe(\n      map((data) => {\n        if (!options?.reducers?.length) {\n          return data; // nothing selected\n        }\n\n        const matcher = options.fields\n          ? getFieldMatcher(options.fields)\n          : options.includeTimeField && options.mode === ReduceTransformerMode.ReduceFields\n            ? alwaysFieldMatcher\n            : notTimeFieldMatcher;\n\n        // Collapse all matching fields into a single row\n        if (options.mode === ReduceTransformerMode.ReduceFields) {\n          return reduceFields(data, matcher, options.reducers);\n        }\n\n        // Add a row for each series\n        const res = reduceSeriesToRows(data, matcher, options.reducers, options.labelsToFields);\n        return res\n          ? [{ ...res, refId: `${DataTransformerID.reduce}-${data.map((frame) => frame.refId).join('-')}` }]\n          : [];\n      })\n    ),\n};\n\n/**\n * @internal only exported for testing\n */\nfunction reduceSeriesToRows(\n  data: DataFrame[],\n  matcher: FieldMatcher,\n  reducerId: ReducerID[],\n  labelsToFields?: boolean\n): DataFrame | undefined {\n  const calculators = fieldReducers.list(reducerId);\n  const reducers = calculators.map((c) => c.id);\n  const processed: DataFrame[] = [];\n  const distinctLabels = labelsToFields ? getDistinctLabelKeys(data) : [];\n\n  for (const series of data) {\n    const source = series.fields.filter((f) => matcher(f, series, data));\n\n    const size = source.length;\n    const fields: Field[] = [];\n    const names: string[] = new Array(size);\n    fields.push({\n      name: 'Field',\n      type: FieldType.string,\n      values: names,\n      config: {},\n    });\n\n    const labels: KeyValue<unknown[]> = {};\n    if (labelsToFields) {\n      for (const key of distinctLabels) {\n        labels[key] = new Array(size);\n        fields.push({\n          name: key,\n          type: FieldType.string,\n          values: labels[key],\n          config: {},\n        });\n      }\n    }\n\n    const calcs: KeyValue<unknown[]> = {};\n    for (const info of calculators) {\n      calcs[info.id] = new Array(size);\n      fields.push({\n        name: info.name,\n        type: FieldType.other, // UNKNOWN until after we call the functions\n        values: calcs[info.id],\n        config: {},\n      });\n    }\n\n    for (let i = 0; i < source.length; i++) {\n      const field = source[i];\n      const results = reduceField({\n        field,\n        reducers,\n      });\n\n      if (labelsToFields) {\n        names[i] = field.name;\n        if (field.labels) {\n          for (const key in field.labels) {\n            labels[key][i] = field.labels[key];\n          }\n        }\n      } else {\n        names[i] = getFieldDisplayName(field, series, data);\n      }\n\n      for (const info of calculators) {\n        const v = results[info.id];\n        if (v === null) {\n          // NaN ensures proper row index, null results in shift\n          calcs[info.id][i] = NaN;\n        } else {\n          calcs[info.id][i] = v;\n        }\n      }\n    }\n\n    // For reduced fields, we don't know the type until we see the value\n    for (const f of fields) {\n      if (f.type === FieldType.other) {\n        const t = guessFieldTypeForField(f);\n        if (t) {\n          f.type = t;\n        }\n      }\n    }\n\n    processed.push({\n      ...series, // Same properties, different fields\n      fields,\n      length: size,\n    });\n  }\n\n  return mergeResults(processed);\n}\n\nfunction getDistinctLabelKeys(frames: DataFrame[]): string[] {\n  const keys = new Set<string>();\n  for (const frame of frames) {\n    for (const field of frame.fields) {\n      if (field.labels) {\n        for (const k of Object.keys(field.labels)) {\n          keys.add(k);\n        }\n      }\n    }\n  }\n  return [...keys];\n}\n\n/**\n * @internal only exported for testing\n */\nfunction mergeResults(data: DataFrame[]): DataFrame | undefined {\n  if (!data?.length) {\n    return undefined;\n  }\n\n  const baseFrame = data[0];\n\n  for (let seriesIndex = 1; seriesIndex < data.length; seriesIndex++) {\n    const series = data[seriesIndex];\n\n    for (let baseIndex = 0; baseIndex < baseFrame.fields.length; baseIndex++) {\n      const baseField = baseFrame.fields[baseIndex];\n      for (let fieldIndex = 0; fieldIndex < series.fields.length; fieldIndex++) {\n        const field = series.fields[fieldIndex];\n        const isFirstField = baseIndex === 0 && fieldIndex === 0;\n        const isSameField = baseField.type === field.type && baseField.name === field.name;\n\n        if (isFirstField || isSameField) {\n          const baseValues = baseField.values;\n          const values = field.values;\n          baseField.values = baseValues.concat(values);\n        }\n      }\n    }\n  }\n\n  baseFrame.name = undefined;\n  baseFrame.length = baseFrame.fields[0].values.length;\n  return baseFrame;\n}\n\n/**\n * @internal -- only exported for testing\n */\nexport function reduceFields(data: DataFrame[], matcher: FieldMatcher, reducerId: ReducerID[]): DataFrame[] {\n  const calculators = fieldReducers.list(reducerId);\n  const reducers = calculators.map((c) => c.id);\n  const processed: DataFrame[] = [];\n  for (const series of data) {\n    const fields: Field[] = [];\n    for (const field of series.fields) {\n      if (matcher(field, series, data)) {\n        const results = reduceField({\n          field,\n          reducers,\n        });\n        for (const reducer of reducers) {\n          const value = results[reducer];\n          const copy = {\n            ...field,\n            type: getFieldType(reducer, field),\n            values: [value],\n          };\n          copy.state = undefined;\n          if (reducers.length > 1) {\n            if (!copy.labels) {\n              copy.labels = {};\n            }\n            copy.labels['reducer'] = fieldReducers.get(reducer).name;\n          }\n          fields.push(copy);\n        }\n      }\n    }\n    if (fields.length) {\n      processed.push({\n        ...series,\n        fields,\n        length: 1, // always one row\n      });\n    }\n  }\n\n  return processed;\n}\n\nfunction getFieldType(reducer: string, field: Field) {\n  switch (reducer) {\n    case ReducerID.allValues:\n    case ReducerID.uniqueValues:\n      return FieldType.other;\n    case ReducerID.first:\n    case ReducerID.firstNotNull:\n    case ReducerID.last:\n    case ReducerID.lastNotNull:\n      return field.type;\n    default:\n      return FieldType.number;\n  }\n}\n"],"names":[],"mappings":"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"}