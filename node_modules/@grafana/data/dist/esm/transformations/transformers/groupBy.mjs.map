{"version":3,"file":"groupBy.mjs","sources":["../../../../src/transformations/transformers/groupBy.ts"],"sourcesContent":["import { map } from 'rxjs/operators';\n\nimport { getFieldDisplayName } from '../../field/fieldState';\nimport { DataFrame, Field } from '../../types/dataFrame';\nimport { DataTransformerInfo, TransformationApplicabilityLevels } from '../../types/transformations';\nimport { getFieldTypeForReducer, reduceField, ReducerID } from '../fieldReducer';\n\nimport { DataTransformerID } from './ids';\nimport { findMaxFields } from './utils';\n\nconst MINIMUM_FIELDS_REQUIRED = 2;\n\nexport enum GroupByOperationID {\n  aggregate = 'aggregate',\n  groupBy = 'groupby',\n}\n\nexport interface GroupByFieldOptions {\n  aggregations: ReducerID[];\n  operation: GroupByOperationID | null;\n}\n\nexport interface GroupByTransformerOptions {\n  fields: Record<string, GroupByFieldOptions>;\n}\n\ninterface FieldMap {\n  [key: string]: Field;\n}\n\nexport const groupByTransformer: DataTransformerInfo<GroupByTransformerOptions> = {\n  id: DataTransformerID.groupBy,\n  name: 'Group by',\n  description: 'Group the data by a field values then process calculations for each group.',\n  defaultOptions: {\n    fields: {},\n  },\n  isApplicable: (data: DataFrame[]) => {\n    // Group by needs at least two fields\n    // a field to group on and a field to aggregate\n    // We make sure that at least one frame has at\n    // least two fields\n    const maxFields = findMaxFields(data);\n\n    return maxFields >= MINIMUM_FIELDS_REQUIRED\n      ? TransformationApplicabilityLevels.Applicable\n      : TransformationApplicabilityLevels.NotApplicable;\n  },\n  isApplicableDescription: (data: DataFrame[]) => {\n    const maxFields = findMaxFields(data);\n    return `The Group by transformation requires a series with at least ${MINIMUM_FIELDS_REQUIRED} fields to work. The maximum number of fields found on a series is ${maxFields}`;\n  },\n  /**\n   * Return a modified copy of the series. If the transform is not or should not\n   * be applied, just return the input series\n   */\n  operator: (options) => (source) =>\n    source.pipe(\n      map((data) => {\n        const hasValidConfig = Object.keys(options.fields).find(\n          (name) => options.fields[name].operation === GroupByOperationID.groupBy\n        );\n\n        if (!hasValidConfig) {\n          return data;\n        }\n\n        const processed: DataFrame[] = [];\n\n        for (const frame of data) {\n          // Create a list of fields to group on\n          // If there are none we skip the rest\n          const groupByFields: Field[] = frame.fields.filter((field) => shouldGroupOnField(field, options));\n          if (groupByFields.length === 0) {\n            continue;\n          }\n\n          // Group the values by fields and groups so we can get all values for a\n          // group for a given field.\n          const valuesByGroupKey = groupValuesByKey(frame, groupByFields);\n\n          // Add the grouped fields to the resulting fields of the transformation\n          const fields: Field[] = createGroupedFields(groupByFields, valuesByGroupKey);\n\n          // Then for each calculations configured, compute and add a new field (column)\n          for (const field of frame.fields) {\n            if (!shouldCalculateField(field, options)) {\n              continue;\n            }\n\n            const fieldName = getFieldDisplayName(field);\n            const aggregations = options.fields[fieldName].aggregations;\n            const valuesByAggregation: Record<string, unknown[]> = {};\n\n            valuesByGroupKey.forEach((value) => {\n              const fieldWithValuesForGroup = value[fieldName];\n              const results = reduceField({\n                field: fieldWithValuesForGroup,\n                reducers: aggregations,\n              });\n\n              for (const aggregation of aggregations) {\n                if (!Array.isArray(valuesByAggregation[aggregation])) {\n                  valuesByAggregation[aggregation] = [];\n                }\n                valuesByAggregation[aggregation].push(results[aggregation]);\n              }\n            });\n\n            for (const aggregation of aggregations) {\n              const aggregationField: Field = {\n                name: `${fieldName} (${aggregation})`,\n                values: valuesByAggregation[aggregation] ?? [],\n                type: getFieldTypeForReducer(aggregation, field.type),\n                config: {},\n              };\n\n              fields.push(aggregationField);\n            }\n          }\n\n          processed.push({\n            ...frame,\n            fields,\n            length: valuesByGroupKey.size,\n          });\n        }\n\n        return processed;\n      })\n    ),\n};\n\nconst shouldGroupOnField = (field: Field, options: GroupByTransformerOptions): boolean => {\n  const fieldName = getFieldDisplayName(field);\n  return options?.fields[fieldName]?.operation === GroupByOperationID.groupBy;\n};\n\nconst shouldCalculateField = (field: Field, options: GroupByTransformerOptions): boolean => {\n  const fieldName = getFieldDisplayName(field);\n  return (\n    options?.fields[fieldName]?.operation === GroupByOperationID.aggregate &&\n    Array.isArray(options?.fields[fieldName].aggregations) &&\n    options?.fields[fieldName].aggregations.length > 0\n  );\n};\n\n/**\n * Groups values together by key. This will create a mapping of strings\n * to _FieldMaps_ that will then be used to group values on.\n *\n * @param frame\n *  The dataframe containing the data to group.\n * @param groupByFields\n *  An array of fields to group on.\n */\nexport function groupValuesByKey(frame: DataFrame, groupByFields: Field[]) {\n  const valuesByGroupKey = new Map<string, FieldMap>();\n\n  for (let rowIndex = 0; rowIndex < frame.length; rowIndex++) {\n    const groupKey = String(groupByFields.map((field) => field.values[rowIndex]));\n    const valuesByField = valuesByGroupKey.get(groupKey) ?? {};\n\n    if (!valuesByGroupKey.has(groupKey)) {\n      valuesByGroupKey.set(groupKey, valuesByField);\n    }\n\n    for (let field of frame.fields) {\n      const fieldName = getFieldDisplayName(field);\n\n      if (!valuesByField[fieldName]) {\n        valuesByField[fieldName] = {\n          name: fieldName,\n          type: field.type,\n          config: { ...field.config },\n          values: [],\n        };\n      }\n\n      valuesByField[fieldName].values.push(field.values[rowIndex]);\n    }\n  }\n\n  return valuesByGroupKey;\n}\n\n/**\n * Create new fields which will be used to display grouped values.\n *\n * @param groupByFields\n * @param valuesByGroupKey\n * @returns\n *  Returns an array of fields that have been grouped.\n */\nexport function createGroupedFields(groupByFields: Field[], valuesByGroupKey: Map<string, FieldMap>): Field[] {\n  const fields: Field[] = [];\n\n  for (const field of groupByFields) {\n    const values: unknown[] = [];\n    const fieldName = getFieldDisplayName(field);\n\n    valuesByGroupKey.forEach((value) => {\n      values.push(value[fieldName].values[0]);\n    });\n\n    fields.push({\n      name: field.name,\n      type: field.type,\n      config: {\n        ...field.config,\n      },\n      values,\n    });\n  }\n\n  return fields;\n}\n"],"names":[],"mappings":"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"}