{"version":3,"file":"joinDataFrames.mjs","sources":["../../../../src/transformations/transformers/joinDataFrames.ts"],"sourcesContent":["import { getTimeField, sortDataFrame } from '../../dataframe/processDataFrame';\nimport { DataFrame, Field, FieldType, TIME_SERIES_VALUE_FIELD_NAME } from '../../types/dataFrame';\nimport { FieldMatcher } from '../../types/transformations';\nimport { fieldMatchers } from '../matchers';\nimport { FieldMatcherID } from '../matchers/ids';\n\nimport { JoinMode } from './joinByField';\n\nexport function pickBestJoinField(data: DataFrame[]): FieldMatcher {\n  const { timeField } = getTimeField(data[0]);\n  if (timeField) {\n    return fieldMatchers.get(FieldMatcherID.firstTimeField).get({});\n  }\n  let common: string[] = [];\n  for (const f of data[0].fields) {\n    if (f.type === FieldType.number) {\n      common.push(f.name);\n    }\n  }\n\n  for (let i = 1; i < data.length; i++) {\n    const names: string[] = [];\n    for (const f of data[0].fields) {\n      if (f.type === FieldType.number) {\n        names.push(f.name);\n      }\n    }\n    common = common.filter((v) => !names.includes(v));\n  }\n\n  return fieldMatchers.get(FieldMatcherID.byName).get(common[0]);\n}\n\n/**\n * @internal\n */\nexport interface JoinOptions {\n  /**\n   * The input fields\n   */\n  frames: DataFrame[];\n\n  /**\n   * The field to join -- frames that do not have this field will be dropped\n   */\n  joinBy?: FieldMatcher;\n\n  /**\n   * Optionally filter the non-join fields\n   */\n  keep?: FieldMatcher;\n\n  /**\n   * @internal -- used when we need to keep a reference to the original frame/field index\n   */\n  keepOriginIndices?: boolean;\n\n  /**\n   * @internal -- keep any pre-cached state.displayName\n   */\n  keepDisplayNames?: boolean;\n\n  /**\n   * @internal -- Optionally specify how to treat null values\n   */\n  nullMode?: (field: Field) => JoinNullMode;\n\n  /**\n   * @internal -- Optionally specify a join mode (outer or inner)\n   */\n  mode?: JoinMode;\n}\n\nfunction getJoinMatcher(options: JoinOptions): FieldMatcher {\n  return options.joinBy ?? pickBestJoinField(options.frames);\n}\n\n/**\n * @internal\n */\nexport function maybeSortFrame(frame: DataFrame, fieldIdx: number) {\n  if (fieldIdx >= 0) {\n    let sortByField = frame.fields[fieldIdx];\n\n    if (sortByField.type !== FieldType.string && !isLikelyAscendingVector(sortByField.values)) {\n      frame = sortDataFrame(frame, fieldIdx);\n    }\n  }\n\n  return frame;\n}\n\n/**\n * This will return a single frame joined by the first matching field.  When a join field is not specified,\n * the default will use the first time field\n */\nexport function joinDataFrames(options: JoinOptions): DataFrame | undefined {\n  if (!options.frames?.length) {\n    return;\n  }\n\n  const nullMode =\n    options.nullMode ??\n    ((field: Field) => {\n      let spanNulls = field.config.custom?.spanNulls;\n      return spanNulls === true ? NULL_REMOVE : spanNulls === -1 ? NULL_RETAIN : NULL_EXPAND;\n    });\n\n  if (options.frames.length === 1) {\n    let frame = options.frames[0];\n    let frameCopy = frame;\n\n    const joinFieldMatcher = getJoinMatcher(options);\n    let joinIndex = frameCopy.fields.findIndex((f) => joinFieldMatcher(f, frameCopy, options.frames));\n\n    if (options.keepOriginIndices) {\n      frameCopy = {\n        ...frame,\n        fields: frame.fields.map((f, fieldIndex) => {\n          const copy = { ...f };\n          const origin = {\n            frameIndex: 0,\n            fieldIndex,\n          };\n          if (copy.state) {\n            copy.state.origin = origin;\n          } else {\n            copy.state = { origin };\n          }\n          return copy;\n        }),\n      };\n\n      // Make sure the join field is first\n      if (joinIndex > 0) {\n        const joinField = frameCopy.fields[joinIndex];\n        const fields = frameCopy.fields.filter((f, idx) => idx !== joinIndex);\n        fields.unshift(joinField);\n        frameCopy.fields = fields;\n        joinIndex = 0;\n      }\n    }\n\n    if (joinIndex >= 0) {\n      frameCopy = maybeSortFrame(frameCopy, joinIndex);\n    }\n\n    if (options.keep) {\n      let fields = frameCopy.fields.filter(\n        (f, fieldIdx) => fieldIdx === joinIndex || options.keep!(f, frameCopy, options.frames)\n      );\n\n      // mutate already copied frame\n      if (frame !== frameCopy) {\n        frameCopy.fields = fields;\n      } else {\n        frameCopy = {\n          ...frame,\n          fields,\n        };\n      }\n    }\n\n    return frameCopy;\n  }\n\n  const nullModes: JoinNullMode[][] = [];\n  const allData: AlignedData[] = [];\n  const originalFields: Field[] = [];\n  // store frame field order for tabular data join\n  const originalFieldsOrderByFrame: number[][] = [];\n  // all other fields that are not the join on are in the 1+ position (join is always the 0)\n  let fieldsOrder = 1;\n  const joinFieldMatcher = getJoinMatcher(options);\n\n  for (let frameIndex = 0; frameIndex < options.frames.length; frameIndex++) {\n    const frame = options.frames[frameIndex];\n\n    if (!frame || !frame.fields?.length) {\n      continue; // skip the frame\n    }\n\n    const nullModesFrame: JoinNullMode[] = [NULL_REMOVE];\n    let join: Field | undefined = undefined;\n    let fields: Field[] = [];\n    let frameFieldsOrder = [];\n\n    for (let fieldIndex = 0; fieldIndex < frame.fields.length; fieldIndex++) {\n      const field = frame.fields[fieldIndex];\n      field.state = field.state || {};\n\n      if (!join && joinFieldMatcher(field, frame, options.frames)) {\n        join = field;\n      } else {\n        if (options.keep && !options.keep(field, frame, options.frames)) {\n          continue; // skip field\n        }\n\n        // Support the standard graph span nulls field config\n        nullModesFrame.push(nullMode(field));\n\n        let labels = field.labels ?? {};\n        let name = field.name;\n        if (frame.name) {\n          if (field.name === TIME_SERIES_VALUE_FIELD_NAME) {\n            name = frame.name;\n          } else if (labels.name == null) {\n            // add the name label from frame\n            labels = { ...labels, name: frame.name };\n          }\n        }\n\n        fields.push({\n          ...field,\n          name,\n          labels,\n        });\n      }\n\n      if (options.keepOriginIndices) {\n        field.state.origin = {\n          frameIndex,\n          fieldIndex,\n        };\n      }\n    }\n\n    if (!join) {\n      continue; // skip the frame\n    }\n\n    if (originalFields.length === 0) {\n      originalFields.push(join); // first join field\n    }\n\n    nullModes.push(nullModesFrame);\n    const a: AlignedData = [join.values]; //\n\n    for (const field of fields) {\n      a.push(field.values);\n      originalFields.push(field);\n      if (!options.keepDisplayNames) {\n        // clear field displayName state\n        delete field.state?.displayName;\n      }\n      // store frame field order for tabular data join\n      frameFieldsOrder.push(fieldsOrder);\n      fieldsOrder++;\n    }\n    // store frame field order for tabular data join\n    originalFieldsOrderByFrame.push(frameFieldsOrder);\n    allData.push(a);\n  }\n\n  let joined: Array<Array<number | string | null | undefined>> = [];\n\n  if (options.mode === JoinMode.outerTabular) {\n    joined = joinOuterTabular(allData, originalFieldsOrderByFrame, originalFields.length, nullModes);\n  } else if (options.mode === JoinMode.inner) {\n    joined = joinInner(allData);\n  } else {\n    joined = join(allData, nullModes, options.mode);\n  }\n\n  return {\n    // ...options.data[0], // keep name, meta?\n    length: joined[0] ? joined[0].length : 0,\n    fields: originalFields.map((f, index) => ({\n      ...f,\n      values: joined[index],\n    })),\n  };\n}\n\n// The following full outer join allows for multiple/duplicated joined fields values where as the performant join from uplot creates a unique set of field values to be joined on\n// http://www.silota.com/docs/recipes/sql-join-tutorial-javascript-examples.html\n// The frame field value which is used join on is sorted to the 0 position of each table data in both tables and nullModes\n// (not sure if we need nullModes) for nullModes, the field to join on is given NULL_REMOVE and all other fields are given NULL_EXPAND\nfunction joinOuterTabular(\n  tables: AlignedData[],\n  originalFieldsOrderByFrame: number[][],\n  numberOfFields: number,\n  nullModes?: number[][]\n) {\n  // we will iterate through all frames and check frames for matches preventing duplicates.\n  // we will store each matched frame \"row\" or field values at the same index in the following hash.\n  let duplicateHash: { [key: string]: Array<number | string | null | undefined> } = {};\n\n  // iterate through the tables (frames)\n  // for each frame we get the field data where the data in the 0 pos is the value to join on\n  for (let tableIdx = 0; tableIdx < tables.length; tableIdx++) {\n    // the table (frame) to check for matches in other tables\n    let table = tables[tableIdx];\n    // the field value to join on (the join value is always in the 0 position)\n    let joinOnTableField = table[0];\n\n    // now we iterate through the other table (frame) data to look for matches\n    for (let otherTablesIdx = 0; otherTablesIdx < tables.length; otherTablesIdx++) {\n      // do not match on the same table\n      if (otherTablesIdx === tableIdx) {\n        continue;\n      }\n\n      let otherTable = tables[otherTablesIdx];\n      let otherTableJoinOnField = otherTable[0];\n\n      // iterate through the field to join on from the first table\n      for (\n        let joinTableFieldValuesIdx = 0;\n        joinTableFieldValuesIdx < joinOnTableField.length;\n        joinTableFieldValuesIdx++\n      ) {\n        // create the joined data\n        // this has the orignalFields length and should start out undefined\n        // joined row + number of other fields in each frame\n        // the order of each field is important in how we\n        // 1 check for duplicates\n        // 2 transform the row back into fields for the joined frame\n        // 3 when there is no match for the row we keep the vals undefined\n        const tableJoinOnValue = joinOnTableField[joinTableFieldValuesIdx];\n        const allOtherFields = numberOfFields - 1;\n        let joinedRow: Array<number | string | null | undefined> = [tableJoinOnValue].concat(new Array(allOtherFields));\n\n        let tableFieldValIdx = 0;\n        for (let fieldsIdx = 1; fieldsIdx < table.length; fieldsIdx++) {\n          const joinRowIdx = originalFieldsOrderByFrame[tableIdx][tableFieldValIdx];\n          joinedRow[joinRowIdx] = table[fieldsIdx][joinTableFieldValuesIdx];\n          tableFieldValIdx++;\n        }\n\n        for (let otherTableValuesIdx = 0; otherTableValuesIdx < otherTableJoinOnField.length; otherTableValuesIdx++) {\n          if (joinOnTableField[joinTableFieldValuesIdx] === otherTableJoinOnField[otherTableValuesIdx]) {\n            let tableFieldValIdx = 0;\n            for (let fieldsIdx = 1; fieldsIdx < otherTable.length; fieldsIdx++) {\n              const joinRowIdx = originalFieldsOrderByFrame[otherTablesIdx][tableFieldValIdx];\n              joinedRow[joinRowIdx] = otherTable[fieldsIdx][otherTableValuesIdx];\n              tableFieldValIdx++;\n            }\n\n            break;\n          }\n        }\n\n        // prevent duplicates by entering rows in a hash where keys are the rows\n        duplicateHash[JSON.stringify(joinedRow)] = joinedRow;\n      }\n    }\n  }\n\n  // transform the joined rows into data for a dataframe\n  let data: Array<Array<number | string | null | undefined>> = [];\n  for (let field = 0; field < numberOfFields; field++) {\n    data.push(new Array(0));\n  }\n\n  for (let key in duplicateHash) {\n    const row = duplicateHash[key];\n\n    for (let valIdx = 0; valIdx < row.length; valIdx++) {\n      data[valIdx].push(row[valIdx]);\n    }\n  }\n\n  return data;\n}\n\n/**\n * This function performs a sql-style inner join on tabular data;\n * it will combine records from two tables whenever there are matching\n * values in a field common to both tables.\n *\n * NOTE: This function implicitly assumes that the first array in each AlignedData\n * contains the values to join on. It doesn't explicitly specify a column field to join on,\n * but rather uses the 0th position of the arrays (AlignedData[0]) to determine the joining keys.\n * Then, when processing the tables, the function iterates over the values in the `xValues`\n * (the joining keys) array and checks if the current row `currentRow` already includes the value.\n * If a matching value is found, it joins the corresponding values from the remaining arrays `yValues`\n * (all other non-joining key arrays) to create a new row in the joined table.\n *\n * @param {AlignedData[]} tables - The tables to join.\n *\n * @returns {Array<Array<string | number | null | undefined>>} The joined tables as an array of arrays, where each array represents a row in the joined table.\n */\nfunction joinInner(tables: AlignedData[]): Array<Array<string | number | null | undefined>> {\n  const joinedTables: Array<Array<string | number | null | undefined>> = [];\n\n  // Recursive function to perform the inner join.\n  const joinTables = (\n    currentTables: AlignedData[],\n    currentIndex: number,\n    currentRow: Array<string | number | null | undefined>\n  ) => {\n    if (currentIndex === currentTables.length) {\n      // Base case: all tables have been joined, add the current row to the final result.\n      joinedTables.push(currentRow);\n      return;\n    }\n\n    const currentTable = currentTables[currentIndex];\n    const [xValues, ...yValues] = currentTable;\n\n    for (let i = 0; i < xValues.length; i++) {\n      const value = xValues[i];\n\n      if (currentIndex === 0 || currentRow.includes(value)) {\n        const newRow = [...currentRow];\n\n        if (currentIndex === 0) {\n          newRow.push(value);\n        }\n\n        for (let j = 0; j < yValues.length; j++) {\n          newRow.push(yValues[j][i]);\n        }\n\n        // Recursive call for the next table\n        joinTables(currentTables, currentIndex + 1, newRow);\n      }\n    }\n  };\n\n  // Start the recursive join process.\n  joinTables(tables, 0, []);\n\n  // Check if joinedTables is empty before transposing. No need to transpose if there are no joined tables.\n  if (joinedTables.length === 0) {\n    const fieldCount = tables.reduce((count, table) => count + (table.length - 1), 1);\n    return Array.from({ length: fieldCount }, () => []);\n  }\n\n  // Transpose the joined tables to get the desired output format.\n  // This essentially flips the rows and columns back to the stucture of the original `tables`.\n  return joinedTables[0].map((_, colIndex) => joinedTables.map((row) => row[colIndex]));\n}\n\n//--------------------------------------------------------------------------------\n// Below here is copied from uplot (MIT License)\n// https://github.com/leeoniya/uPlot/blob/master/src/utils.js#L325\n// This avoids needing to import uplot into the data package\n//--------------------------------------------------------------------------------\n\n// Copied from uplot\nexport type TypedArray =\n  | Int8Array\n  | Uint8Array\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Uint8ClampedArray\n  | Float32Array\n  | Float64Array;\n\nexport type AlignedData =\n  | TypedArray[]\n  | [xValues: number[] | TypedArray, ...yValues: Array<Array<number | null | undefined> | TypedArray>];\n\n// nullModes\nexport const NULL_REMOVE = 0; // nulls are converted to undefined (e.g. for spanGaps: true)\nexport const NULL_RETAIN = 1; // nulls are retained, with alignment artifacts set to undefined (default)\nexport const NULL_EXPAND = 2; // nulls are expanded to include any adjacent alignment artifacts\n\ntype JoinNullMode = number; // NULL_IGNORE | NULL_RETAIN | NULL_EXPAND;\n\n// sets undefined values to nulls when adjacent to existing nulls (minesweeper)\nfunction nullExpand(yVals: Array<number | null>, nullIdxs: number[], alignedLen: number) {\n  for (let i = 0, xi, lastNullIdx = -1; i < nullIdxs.length; i++) {\n    let nullIdx = nullIdxs[i];\n\n    if (nullIdx > lastNullIdx) {\n      xi = nullIdx - 1;\n      while (xi >= 0 && yVals[xi] == null) {\n        yVals[xi--] = null;\n      }\n\n      xi = nullIdx + 1;\n      while (xi < alignedLen && yVals[xi] == null) {\n        yVals[(lastNullIdx = xi++)] = null;\n      }\n    }\n  }\n}\n\n// nullModes is a tables-matched array indicating how to treat nulls in each series\nexport function join(tables: AlignedData[], nullModes?: number[][], mode: JoinMode = JoinMode.outer) {\n  let xVals: Set<number> = new Set();\n\n  for (let ti = 0; ti < tables.length; ti++) {\n    let t = tables[ti];\n    let xs = t[0];\n    let len = xs.length;\n\n    for (let i = 0; i < len; i++) {\n      xVals.add(xs[i]);\n    }\n  }\n\n  let data = [Array.from(xVals).sort((a, b) => a - b)];\n\n  let alignedLen = data[0].length;\n\n  let xIdxs = new Map();\n\n  for (let i = 0; i < alignedLen; i++) {\n    xIdxs.set(data[0][i], i);\n  }\n\n  for (let ti = 0; ti < tables.length; ti++) {\n    let t = tables[ti];\n    let xs = t[0];\n\n    for (let si = 1; si < t.length; si++) {\n      let ys = t[si];\n\n      let yVals = Array(alignedLen).fill(undefined);\n\n      let nullMode = nullModes ? nullModes[ti][si] : NULL_RETAIN;\n\n      let nullIdxs = [];\n\n      for (let i = 0; i < ys.length; i++) {\n        let yVal = ys[i];\n        let alignedIdx = xIdxs.get(xs[i]);\n\n        if (yVal === null) {\n          if (nullMode !== NULL_REMOVE) {\n            yVals[alignedIdx] = yVal;\n\n            if (nullMode === NULL_EXPAND) {\n              nullIdxs.push(alignedIdx);\n            }\n          }\n        } else {\n          yVals[alignedIdx] = yVal;\n        }\n      }\n\n      nullExpand(yVals, nullIdxs, alignedLen);\n\n      data.push(yVals);\n    }\n  }\n\n  return data;\n}\n\n// Test a few samples to see if the values are ascending\n// Only exported for tests\nexport function isLikelyAscendingVector(data: unknown[], samples = 50) {\n  const len = data.length;\n\n  // empty or single value\n  if (len <= 1) {\n    return true;\n  }\n\n  // skip leading & trailing nullish\n  let firstIdx = 0;\n  let lastIdx = len - 1;\n\n  while (firstIdx <= lastIdx && data[firstIdx] == null) {\n    firstIdx++;\n  }\n\n  while (lastIdx >= firstIdx && data[lastIdx] == null) {\n    lastIdx--;\n  }\n\n  // all nullish or one value surrounded by nullish\n  if (lastIdx <= firstIdx) {\n    return true;\n  }\n\n  const stride = Math.max(1, Math.floor((lastIdx - firstIdx + 1) / samples));\n\n  for (let prevVal = data[firstIdx], i = firstIdx + stride; i <= lastIdx; i += stride) {\n    const v = data[i];\n\n    if (v != null && prevVal != null) {\n      if (v <= prevVal) {\n        return false;\n      }\n\n      prevVal = v;\n    }\n  }\n\n  return true;\n}\n"],"names":["_a","joinFieldMatcher","join","tableFieldValIdx"],"mappings":"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"}