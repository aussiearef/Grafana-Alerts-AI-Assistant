{"version":3,"file":"filterByName.mjs","sources":["../../../../src/transformations/transformers/filterByName.ts"],"sourcesContent":["import { DataTransformerInfo, MatcherConfig } from '../../types/transformations';\nimport { FieldMatcherID } from '../matchers/ids';\nimport { RegexpOrNamesMatcherOptions } from '../matchers/nameMatcher';\n\nimport { filterFieldsTransformer } from './filter';\nimport { DataTransformerID } from './ids';\n\nexport interface FilterFieldsByNameTransformerOptions {\n  include?: RegexpOrNamesMatcherOptions;\n  exclude?: RegexpOrNamesMatcherOptions;\n  byVariable?: boolean;\n}\n\nexport const filterFieldsByNameTransformer: DataTransformerInfo<FilterFieldsByNameTransformerOptions> = {\n  id: DataTransformerID.filterFieldsByName,\n  name: 'Filter fields by name',\n  description: 'select a subset of fields',\n  defaultOptions: {},\n\n  /**\n   * Return a modified copy of the series. If the transform is not or should not\n   * be applied, just return the input series\n   */\n  operator: (options, ctx) => (source) =>\n    source.pipe(\n      filterFieldsTransformer.operator(\n        {\n          include: getMatcherConfig(options.include, options.byVariable),\n          exclude: getMatcherConfig(options.exclude, options.byVariable),\n        },\n        ctx\n      )\n    ),\n};\n\n// Exported to share with other implementations, but not exported to `@grafana/data`\nexport const getMatcherConfig = (\n  options?: RegexpOrNamesMatcherOptions,\n  byVariable?: boolean\n): MatcherConfig | undefined => {\n  if (!options) {\n    return undefined;\n  }\n\n  const { names, pattern, variable } = options;\n\n  if (byVariable && variable) {\n    const stringOfNames = variable;\n\n    if (/\\{.*\\}/.test(stringOfNames)) {\n      const namesFromString = stringOfNames.slice(1).slice(0, -1).split(',');\n      return { id: FieldMatcherID.byNames, options: { names: namesFromString } };\n    }\n    return { id: FieldMatcherID.byNames, options: { names: stringOfNames.split(',') } };\n  }\n\n  if ((!Array.isArray(names) || names.length === 0) && !pattern) {\n    return undefined;\n  }\n\n  if (!pattern) {\n    return { id: FieldMatcherID.byNames, options: { names } };\n  }\n\n  if (!Array.isArray(names) || names.length === 0) {\n    return { id: FieldMatcherID.byRegexp, options: pattern };\n  }\n\n  return { id: FieldMatcherID.byRegexpOrNames, options };\n};\n"],"names":[],"mappings":";;;;AAaO,MAAM,6BAA2F,GAAA;AAAA,EACtG,IAAI,iBAAkB,CAAA,kBAAA;AAAA,EACtB,IAAM,EAAA,uBAAA;AAAA,EACN,WAAa,EAAA,2BAAA;AAAA,EACb,gBAAgB,EAAC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMjB,UAAU,CAAC,OAAA,EAAS,GAAQ,KAAA,CAAC,WAC3B,MAAO,CAAA,IAAA;AAAA,IACL,uBAAwB,CAAA,QAAA;AAAA,MACtB;AAAA,QACE,OAAS,EAAA,gBAAA,CAAiB,OAAQ,CAAA,OAAA,EAAS,QAAQ,UAAU,CAAA;AAAA,QAC7D,OAAS,EAAA,gBAAA,CAAiB,OAAQ,CAAA,OAAA,EAAS,QAAQ,UAAU;AAAA,OAC/D;AAAA,MACA;AAAA;AACF;AAEN;AAGa,MAAA,gBAAA,GAAmB,CAC9B,OAAA,EACA,UAC8B,KAAA;AAC9B,EAAA,IAAI,CAAC,OAAS,EAAA;AACZ,IAAO,OAAA,SAAA;AAAA;AAGT,EAAA,MAAM,EAAE,KAAA,EAAO,OAAS,EAAA,QAAA,EAAa,GAAA,OAAA;AAErC,EAAA,IAAI,cAAc,QAAU,EAAA;AAC1B,IAAA,MAAM,aAAgB,GAAA,QAAA;AAEtB,IAAI,IAAA,QAAA,CAAS,IAAK,CAAA,aAAa,CAAG,EAAA;AAChC,MAAM,MAAA,eAAA,GAAkB,aAAc,CAAA,KAAA,CAAM,CAAC,CAAA,CAAE,MAAM,CAAG,EAAA,EAAE,CAAE,CAAA,KAAA,CAAM,GAAG,CAAA;AACrE,MAAO,OAAA,EAAE,IAAI,cAAe,CAAA,OAAA,EAAS,SAAS,EAAE,KAAA,EAAO,iBAAkB,EAAA;AAAA;AAE3E,IAAO,OAAA,EAAE,EAAI,EAAA,cAAA,CAAe,OAAS,EAAA,OAAA,EAAS,EAAE,KAAA,EAAO,aAAc,CAAA,KAAA,CAAM,GAAG,CAAA,EAAI,EAAA;AAAA;AAGpF,EAAK,IAAA,CAAA,CAAC,MAAM,OAAQ,CAAA,KAAK,KAAK,KAAM,CAAA,MAAA,KAAW,CAAM,KAAA,CAAC,OAAS,EAAA;AAC7D,IAAO,OAAA,SAAA;AAAA;AAGT,EAAA,IAAI,CAAC,OAAS,EAAA;AACZ,IAAA,OAAO,EAAE,EAAI,EAAA,cAAA,CAAe,SAAS,OAAS,EAAA,EAAE,OAAQ,EAAA;AAAA;AAG1D,EAAA,IAAI,CAAC,KAAM,CAAA,OAAA,CAAQ,KAAK,CAAK,IAAA,KAAA,CAAM,WAAW,CAAG,EAAA;AAC/C,IAAA,OAAO,EAAE,EAAA,EAAI,cAAe,CAAA,QAAA,EAAU,SAAS,OAAQ,EAAA;AAAA;AAGzD,EAAA,OAAO,EAAE,EAAA,EAAI,cAAe,CAAA,eAAA,EAAiB,OAAQ,EAAA;AACvD;;;;"}