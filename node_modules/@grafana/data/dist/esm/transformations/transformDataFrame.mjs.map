{"version":3,"file":"transformDataFrame.mjs","sources":["../../../src/transformations/transformDataFrame.ts"],"sourcesContent":["import { cloneDeep } from 'lodash';\nimport { MonoTypeOperatorFunction, Observable, of } from 'rxjs';\nimport { map, mergeMap } from 'rxjs/operators';\n\nimport { DataFrame } from '../types/dataFrame';\nimport {\n  CustomTransformOperator,\n  DataTransformContext,\n  DataTransformerConfig,\n  FrameMatcher,\n} from '../types/transformations';\n\nimport { getFrameMatchers } from './matchers';\nimport { standardTransformersRegistry, TransformerRegistryItem } from './standardTransformersRegistry';\n\nconst getOperator =\n  (config: DataTransformerConfig, ctx: DataTransformContext): MonoTypeOperatorFunction<DataFrame[]> =>\n  (source) => {\n    const info = standardTransformersRegistry.get(config.id);\n\n    if (!info) {\n      return source;\n    }\n\n    const defaultOptions = info.transformation.defaultOptions ?? {};\n    const options = { ...defaultOptions, ...config.options };\n\n    // when running within Scenes, we can skip var interpolation, since it's already handled upstream\n    const isScenes = window.__grafanaSceneContext != null;\n\n    const interpolated = isScenes\n      ? options\n      : deepIterate(cloneDeep(options), (v) => {\n          if (typeof v === 'string') {\n            return ctx.interpolate(v);\n          }\n          return v;\n        });\n\n    const matcher = config.filter?.options ? getFrameMatchers(config.filter) : undefined;\n    return source.pipe(\n      mergeMap((before) =>\n        of(filterInput(before, matcher)).pipe(\n          info.transformation.operator(interpolated, ctx),\n          postProcessTransform(before, info, matcher)\n        )\n      )\n    );\n  };\n\nfunction filterInput(data: DataFrame[], matcher?: FrameMatcher) {\n  if (matcher) {\n    return data.filter((v) => matcher(v));\n  }\n  return data;\n}\n\nconst postProcessTransform =\n  (before: DataFrame[], info: TransformerRegistryItem, matcher?: FrameMatcher): MonoTypeOperatorFunction<DataFrame[]> =>\n  (source) =>\n    source.pipe(\n      map((after) => {\n        if (after === before) {\n          return after;\n        }\n\n        // Add back the filtered out frames\n        if (matcher) {\n          // keep the frame order the same\n          let insert = 0;\n          const append = before.filter((v, idx) => {\n            const keep = !matcher(v);\n            if (keep && !insert) {\n              insert = idx;\n            }\n            return keep;\n          });\n          if (append.length) {\n            after.splice(insert, 0, ...append);\n          }\n        }\n        return after;\n      })\n    );\n\n/**\n * Apply configured transformations to the input data\n */\nexport function transformDataFrame(\n  options: Array<DataTransformerConfig | CustomTransformOperator>,\n  data: DataFrame[],\n  ctx?: DataTransformContext\n): Observable<DataFrame[]> {\n  const stream = of<DataFrame[]>(data);\n\n  if (!options.length) {\n    return stream;\n  }\n\n  const operators: Array<MonoTypeOperatorFunction<DataFrame[]>> = [];\n  const context = ctx ?? { interpolate: (str) => str };\n\n  for (let index = 0; index < options.length; index++) {\n    const config = options[index];\n\n    if (isCustomTransformation(config)) {\n      operators.push(config(context));\n    } else {\n      if (config.disabled) {\n        continue;\n      }\n      operators.push(getOperator(config, context));\n    }\n  }\n\n  // @ts-ignore TypeScript has a hard time understanding this construct\n  return stream.pipe.apply(stream, operators);\n}\n\nfunction isCustomTransformation(t: DataTransformerConfig | CustomTransformOperator): t is CustomTransformOperator {\n  return typeof t === 'function';\n}\n\nfunction deepIterate<T extends object>(obj: T, doSomething: (current: any) => any): T;\n// eslint-disable-next-line no-redeclare\nfunction deepIterate(obj: any, doSomething: (current: any) => any): any {\n  if (Array.isArray(obj)) {\n    return obj.map((o) => deepIterate(o, doSomething));\n  }\n\n  if (typeof obj === 'object') {\n    for (const key in obj) {\n      obj[key] = deepIterate(obj[key], doSomething);\n    }\n\n    return obj;\n  } else {\n    return doSomething(obj) ?? obj;\n  }\n}\n"],"names":[],"mappings":"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"}