{"version":3,"file":"datemath.mjs","sources":["../../../src/datetime/datemath.ts"],"sourcesContent":["import { isDate } from 'lodash';\n\nimport { TimeZone } from '@grafana/schema';\n\nimport {\n  DateTime,\n  dateTime,\n  dateTimeAsMoment,\n  dateTimeForTimeZone,\n  DateTimeInput,\n  DurationUnit,\n  isDateTime,\n  ISO_8601,\n} from './moment_wrapper';\n\nconst units: string[] = ['y', 'M', 'w', 'd', 'h', 'm', 's', 'Q'] satisfies DurationUnit[];\n\nconst isDurationUnit = (value: string): value is DurationUnit => {\n  return units.includes(value);\n};\n\n/**\n * Determine if a string contains a relative date time.\n * @param text\n */\nexport function isMathString(text: string | DateTime | Date): boolean {\n  if (!text) {\n    return false;\n  }\n\n  if (typeof text === 'string' && (text.substring(0, 3) === 'now' || text.includes('||'))) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * @deprecated use toDateTime instead\n * Parses different types input to a moment instance. There is a specific formatting language that can be used\n * if text arg is string. See unit tests for examples.\n * @param text\n * @param roundUp See parseDateMath function.\n * @param timezone Only string 'utc' is acceptable here, for anything else, local timezone is used.\n */\nexport function parse(\n  text?: string | DateTime | Date | null,\n  roundUp?: boolean,\n  timezone?: TimeZone,\n  fiscalYearStartMonth?: number\n): DateTime | undefined {\n  if (!text) {\n    return undefined;\n  }\n  return toDateTime(text, { roundUp, timezone, fiscalYearStartMonth });\n}\n\nexport interface ConversionOptions {\n  /**\n   * Set the time to endOf time unit, otherwise to startOf time unit.\n   */\n  roundUp?: boolean;\n  /**\n   * Only string 'utc' is acceptable here, for anything else, local timezone is used.\n   */\n  timezone?: TimeZone;\n  /**\n   * Setting for which month is the first month of the fiscal year.\n   */\n  fiscalYearStartMonth?: number;\n  /**\n   * DateTimeInput to use as now. Useful when parsing multiple values and now needs to be the same. Without this, comparing results from subsequent parses is not guaranteed to be deterministic.\n   */\n  now?: DateTimeInput;\n}\n\n/**\n * @param dateTimeRep A DateTime object, a Date object or a string representation of a specific time.\n * @param options Options for converting to DateTime\n * @returns A DateTime object if possible, undefined if not.\n */\nexport function toDateTime(dateTimeRep: string | DateTime | Date, options: ConversionOptions): DateTime | undefined {\n  if (typeof dateTimeRep !== 'string') {\n    if (isDateTime(dateTimeRep)) {\n      return dateTimeRep;\n    }\n\n    if (isDate(dateTimeRep)) {\n      return dateTime(dateTimeRep);\n    }\n\n    // We got some non string which is not a moment nor Date. TS should be able to check for that but not always.\n    return undefined;\n  } else {\n    let time: DateTime;\n    let mathString = '';\n    let index = -1;\n    let parseString = '';\n\n    if (dateTimeRep.substring(0, 3) === 'now') {\n      time = dateTimeForTimeZone(options.timezone, options.now);\n      mathString = dateTimeRep.substring('now'.length);\n    } else {\n      index = dateTimeRep.indexOf('||');\n      if (index === -1) {\n        parseString = dateTimeRep;\n        mathString = ''; // nothing else\n      } else {\n        parseString = dateTimeRep.substring(0, index);\n        mathString = dateTimeRep.substring(index + 2);\n      }\n      // We're going to just require ISO8601 timestamps, k?\n      time = dateTime(parseString, ISO_8601);\n    }\n\n    if (!mathString.length) {\n      return time;\n    }\n\n    return parseDateMath(mathString, time, options.roundUp, options.fiscalYearStartMonth);\n  }\n}\n\n/**\n * Checks if text is a valid date which in this context means that it is either a Moment instance or it can be parsed\n * by parse function. See parse function to see what is considered acceptable.\n * @param text\n */\nexport function isValid(text: string | DateTime): boolean {\n  const date = parse(text);\n  if (!date) {\n    return false;\n  }\n\n  if (isDateTime(date)) {\n    return date.isValid();\n  }\n\n  return false;\n}\n\n/**\n * Parses math part of the time string and shifts supplied time according to that math. See unit tests for examples.\n * @param mathString\n * @param time\n * @param roundUp If true it will round the time to endOf time unit, otherwise to startOf time unit.\n */\nexport function parseDateMath(\n  mathString: string,\n  time: DateTime,\n  roundUp?: boolean,\n  fiscalYearStartMonth = 0\n): DateTime | undefined {\n  const strippedMathString = mathString.replace(/\\s/g, '');\n  const result = dateTime(time);\n  let i = 0;\n  const len = strippedMathString.length;\n\n  while (i < len) {\n    const c = strippedMathString.charAt(i++);\n    let type;\n    let num;\n    let unitString: string;\n    let isFiscal = false;\n\n    if (c === '/') {\n      type = 0;\n    } else if (c === '+') {\n      type = 1;\n    } else if (c === '-') {\n      type = 2;\n    } else {\n      return undefined;\n    }\n\n    if (isNaN(parseInt(strippedMathString.charAt(i), 10))) {\n      num = 1;\n    } else if (strippedMathString.length === 2) {\n      num = parseInt(strippedMathString.charAt(i), 10);\n    } else {\n      const numFrom = i;\n      while (!isNaN(parseInt(strippedMathString.charAt(i), 10))) {\n        i++;\n        if (i > 10) {\n          return undefined;\n        }\n      }\n      num = parseInt(strippedMathString.substring(numFrom, i), 10);\n    }\n\n    if (type === 0) {\n      // rounding is only allowed on whole, single, units (eg M or 1M, not 0.5M or 2M)\n      if (num !== 1) {\n        return undefined;\n      }\n    }\n\n    unitString = strippedMathString.charAt(i++);\n\n    if (unitString === 'f') {\n      unitString = strippedMathString.charAt(i++);\n      isFiscal = true;\n    }\n\n    const unit = unitString;\n\n    if (isDurationUnit(unit)) {\n      if (type === 0) {\n        if (isFiscal) {\n          roundToFiscal(fiscalYearStartMonth, result, unit, roundUp);\n        } else {\n          if (roundUp) {\n            result.endOf(unit);\n          } else {\n            result.startOf(unit);\n          }\n        }\n      } else if (type === 1) {\n        result.add(num, unit);\n      } else if (type === 2) {\n        result.subtract(num, unit);\n      }\n    } else {\n      return undefined;\n    }\n  }\n  return result;\n}\n\nexport function roundToFiscal(fyStartMonth: number, dateTime: DateTime, unit: string, roundUp: boolean | undefined) {\n  switch (unit) {\n    case 'y':\n      if (roundUp) {\n        roundToFiscal(fyStartMonth, dateTime, unit, false)?.add(11, 'M').endOf('M');\n      } else {\n        dateTime.subtract((dateTimeAsMoment(dateTime).month() - fyStartMonth + 12) % 12, 'M').startOf('M');\n      }\n      return dateTime;\n    case 'Q':\n      if (roundUp) {\n        roundToFiscal(fyStartMonth, dateTime, unit, false)?.add(2, 'M').endOf('M');\n      } else {\n        // why + 12? to ensure this number is always a positive offset from fyStartMonth\n        dateTime.subtract((dateTimeAsMoment(dateTime).month() - fyStartMonth + 12) % 3, 'M').startOf('M');\n      }\n      return dateTime;\n    default:\n      return undefined;\n  }\n}\n"],"names":["dateTime"],"mappings":";;;AAeA,MAAM,KAAA,GAAkB,CAAC,GAAK,EAAA,GAAA,EAAK,KAAK,GAAK,EAAA,GAAA,EAAK,GAAK,EAAA,GAAA,EAAK,GAAG,CAAA;AAE/D,MAAM,cAAA,GAAiB,CAAC,KAAyC,KAAA;AAC/D,EAAO,OAAA,KAAA,CAAM,SAAS,KAAK,CAAA;AAC7B,CAAA;AAMO,SAAS,aAAa,IAAyC,EAAA;AACpE,EAAA,IAAI,CAAC,IAAM,EAAA;AACT,IAAO,OAAA,KAAA;AAAA;AAGT,EAAA,IAAI,OAAO,IAAA,KAAS,QAAa,KAAA,IAAA,CAAK,SAAU,CAAA,CAAA,EAAG,CAAC,CAAA,KAAM,KAAS,IAAA,IAAA,CAAK,QAAS,CAAA,IAAI,CAAI,CAAA,EAAA;AACvF,IAAO,OAAA,IAAA;AAAA,GACF,MAAA;AACL,IAAO,OAAA,KAAA;AAAA;AAEX;AAUO,SAAS,KACd,CAAA,IAAA,EACA,OACA,EAAA,QAAA,EACA,oBACsB,EAAA;AACtB,EAAA,IAAI,CAAC,IAAM,EAAA;AACT,IAAO,OAAA,SAAA;AAAA;AAET,EAAA,OAAO,WAAW,IAAM,EAAA,EAAE,OAAS,EAAA,QAAA,EAAU,sBAAsB,CAAA;AACrE;AA0BgB,SAAA,UAAA,CAAW,aAAuC,OAAkD,EAAA;AAClH,EAAI,IAAA,OAAO,gBAAgB,QAAU,EAAA;AACnC,IAAI,IAAA,UAAA,CAAW,WAAW,CAAG,EAAA;AAC3B,MAAO,OAAA,WAAA;AAAA;AAGT,IAAI,IAAA,MAAA,CAAO,WAAW,CAAG,EAAA;AACvB,MAAA,OAAO,SAAS,WAAW,CAAA;AAAA;AAI7B,IAAO,OAAA,SAAA;AAAA,GACF,MAAA;AACL,IAAI,IAAA,IAAA;AACJ,IAAA,IAAI,UAAa,GAAA,EAAA;AACjB,IAAA,IAAI,KAAQ,GAAA,EAAA;AACZ,IAAA,IAAI,WAAc,GAAA,EAAA;AAElB,IAAA,IAAI,WAAY,CAAA,SAAA,CAAU,CAAG,EAAA,CAAC,MAAM,KAAO,EAAA;AACzC,MAAA,IAAA,GAAO,mBAAoB,CAAA,OAAA,CAAQ,QAAU,EAAA,OAAA,CAAQ,GAAG,CAAA;AACxD,MAAa,UAAA,GAAA,WAAA,CAAY,SAAU,CAAA,KAAA,CAAM,MAAM,CAAA;AAAA,KAC1C,MAAA;AACL,MAAQ,KAAA,GAAA,WAAA,CAAY,QAAQ,IAAI,CAAA;AAChC,MAAA,IAAI,UAAU,EAAI,EAAA;AAChB,QAAc,WAAA,GAAA,WAAA;AACd,QAAa,UAAA,GAAA,EAAA;AAAA,OACR,MAAA;AACL,QAAc,WAAA,GAAA,WAAA,CAAY,SAAU,CAAA,CAAA,EAAG,KAAK,CAAA;AAC5C,QAAa,UAAA,GAAA,WAAA,CAAY,SAAU,CAAA,KAAA,GAAQ,CAAC,CAAA;AAAA;AAG9C,MAAO,IAAA,GAAA,QAAA,CAAS,aAAa,QAAQ,CAAA;AAAA;AAGvC,IAAI,IAAA,CAAC,WAAW,MAAQ,EAAA;AACtB,MAAO,OAAA,IAAA;AAAA;AAGT,IAAA,OAAO,cAAc,UAAY,EAAA,IAAA,EAAM,OAAQ,CAAA,OAAA,EAAS,QAAQ,oBAAoB,CAAA;AAAA;AAExF;AAOO,SAAS,QAAQ,IAAkC,EAAA;AACxD,EAAM,MAAA,IAAA,GAAO,MAAM,IAAI,CAAA;AACvB,EAAA,IAAI,CAAC,IAAM,EAAA;AACT,IAAO,OAAA,KAAA;AAAA;AAGT,EAAI,IAAA,UAAA,CAAW,IAAI,CAAG,EAAA;AACpB,IAAA,OAAO,KAAK,OAAQ,EAAA;AAAA;AAGtB,EAAO,OAAA,KAAA;AACT;AAQO,SAAS,aACd,CAAA,UAAA,EACA,IACA,EAAA,OAAA,EACA,uBAAuB,CACD,EAAA;AACtB,EAAA,MAAM,kBAAqB,GAAA,UAAA,CAAW,OAAQ,CAAA,KAAA,EAAO,EAAE,CAAA;AACvD,EAAM,MAAA,MAAA,GAAS,SAAS,IAAI,CAAA;AAC5B,EAAA,IAAI,CAAI,GAAA,CAAA;AACR,EAAA,MAAM,MAAM,kBAAmB,CAAA,MAAA;AAE/B,EAAA,OAAO,IAAI,GAAK,EAAA;AACd,IAAM,MAAA,CAAA,GAAI,kBAAmB,CAAA,MAAA,CAAO,CAAG,EAAA,CAAA;AACvC,IAAI,IAAA,IAAA;AACJ,IAAI,IAAA,GAAA;AACJ,IAAI,IAAA,UAAA;AACJ,IAAA,IAAI,QAAW,GAAA,KAAA;AAEf,IAAA,IAAI,MAAM,GAAK,EAAA;AACb,MAAO,IAAA,GAAA,CAAA;AAAA,KACT,MAAA,IAAW,MAAM,GAAK,EAAA;AACpB,MAAO,IAAA,GAAA,CAAA;AAAA,KACT,MAAA,IAAW,MAAM,GAAK,EAAA;AACpB,MAAO,IAAA,GAAA,CAAA;AAAA,KACF,MAAA;AACL,MAAO,OAAA,SAAA;AAAA;AAGT,IAAI,IAAA,KAAA,CAAM,SAAS,kBAAmB,CAAA,MAAA,CAAO,CAAC,CAAG,EAAA,EAAE,CAAC,CAAG,EAAA;AACrD,MAAM,GAAA,GAAA,CAAA;AAAA,KACR,MAAA,IAAW,kBAAmB,CAAA,MAAA,KAAW,CAAG,EAAA;AAC1C,MAAA,GAAA,GAAM,QAAS,CAAA,kBAAA,CAAmB,MAAO,CAAA,CAAC,GAAG,EAAE,CAAA;AAAA,KAC1C,MAAA;AACL,MAAA,MAAM,OAAU,GAAA,CAAA;AAChB,MAAO,OAAA,CAAC,MAAM,QAAS,CAAA,kBAAA,CAAmB,OAAO,CAAC,CAAA,EAAG,EAAE,CAAC,CAAG,EAAA;AACzD,QAAA,CAAA,EAAA;AACA,QAAA,IAAI,IAAI,EAAI,EAAA;AACV,UAAO,OAAA,SAAA;AAAA;AACT;AAEF,MAAA,GAAA,GAAM,SAAS,kBAAmB,CAAA,SAAA,CAAU,OAAS,EAAA,CAAC,GAAG,EAAE,CAAA;AAAA;AAG7D,IAAA,IAAI,SAAS,CAAG,EAAA;AAEd,MAAA,IAAI,QAAQ,CAAG,EAAA;AACb,QAAO,OAAA,SAAA;AAAA;AACT;AAGF,IAAa,UAAA,GAAA,kBAAA,CAAmB,OAAO,CAAG,EAAA,CAAA;AAE1C,IAAA,IAAI,eAAe,GAAK,EAAA;AACtB,MAAa,UAAA,GAAA,kBAAA,CAAmB,OAAO,CAAG,EAAA,CAAA;AAC1C,MAAW,QAAA,GAAA,IAAA;AAAA;AAGb,IAAA,MAAM,IAAO,GAAA,UAAA;AAEb,IAAI,IAAA,cAAA,CAAe,IAAI,CAAG,EAAA;AACxB,MAAA,IAAI,SAAS,CAAG,EAAA;AACd,QAAA,IAAI,QAAU,EAAA;AACZ,UAAc,aAAA,CAAA,oBAAA,EAAsB,MAAQ,EAAA,IAAA,EAAM,OAAO,CAAA;AAAA,SACpD,MAAA;AACL,UAAA,IAAI,OAAS,EAAA;AACX,YAAA,MAAA,CAAO,MAAM,IAAI,CAAA;AAAA,WACZ,MAAA;AACL,YAAA,MAAA,CAAO,QAAQ,IAAI,CAAA;AAAA;AACrB;AACF,OACF,MAAA,IAAW,SAAS,CAAG,EAAA;AACrB,QAAO,MAAA,CAAA,GAAA,CAAI,KAAK,IAAI,CAAA;AAAA,OACtB,MAAA,IAAW,SAAS,CAAG,EAAA;AACrB,QAAO,MAAA,CAAA,QAAA,CAAS,KAAK,IAAI,CAAA;AAAA;AAC3B,KACK,MAAA;AACL,MAAO,OAAA,SAAA;AAAA;AACT;AAEF,EAAO,OAAA,MAAA;AACT;AAEO,SAAS,aAAc,CAAA,YAAA,EAAsBA,SAAoB,EAAA,IAAA,EAAc,OAA8B,EAAA;AArOpH,EAAA,IAAA,EAAA,EAAA,EAAA;AAsOE,EAAA,QAAQ,IAAM;AAAA,IACZ,KAAK,GAAA;AACH,MAAA,IAAI,OAAS,EAAA;AACX,QAAc,CAAA,EAAA,GAAA,aAAA,CAAA,YAAA,EAAcA,WAAU,IAAM,EAAA,KAAK,MAAjD,IAAoD,GAAA,SAAA,GAAA,EAAA,CAAA,GAAA,CAAI,EAAI,EAAA,GAAA,CAAA,CAAK,KAAM,CAAA,GAAA,CAAA;AAAA,OAClE,MAAA;AACL,QAAAA,SAAS,CAAA,QAAA,CAAA,CAAU,gBAAiBA,CAAAA,SAAQ,CAAE,CAAA,KAAA,EAAU,GAAA,YAAA,GAAe,EAAM,IAAA,EAAA,EAAI,GAAG,CAAA,CAAE,QAAQ,GAAG,CAAA;AAAA;AAEnG,MAAOA,OAAAA,SAAAA;AAAA,IACT,KAAK,GAAA;AACH,MAAA,IAAI,OAAS,EAAA;AACX,QAAc,CAAA,EAAA,GAAA,aAAA,CAAA,YAAA,EAAcA,WAAU,IAAM,EAAA,KAAK,MAAjD,IAAoD,GAAA,SAAA,GAAA,EAAA,CAAA,GAAA,CAAI,CAAG,EAAA,GAAA,CAAA,CAAK,KAAM,CAAA,GAAA,CAAA;AAAA,OACjE,MAAA;AAEL,QAAAA,SAAS,CAAA,QAAA,CAAA,CAAU,gBAAiBA,CAAAA,SAAQ,CAAE,CAAA,KAAA,EAAU,GAAA,YAAA,GAAe,EAAM,IAAA,CAAA,EAAG,GAAG,CAAA,CAAE,QAAQ,GAAG,CAAA;AAAA;AAElG,MAAOA,OAAAA,SAAAA;AAAA,IACT;AACE,MAAO,OAAA,SAAA;AAAA;AAEb;;;;"}