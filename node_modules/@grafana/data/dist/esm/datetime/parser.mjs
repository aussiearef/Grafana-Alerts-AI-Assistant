import { lowerCase } from 'lodash';
import moment from 'moment-timezone';
import { getTimeZone } from './common.mjs';
import { parse, isValid } from './datemath.mjs';
import { systemDateFormats } from './formats.mjs';
import { isDateTime, dateTime, dateTimeForTimeZone, toUtc } from './moment_wrapper.mjs';

const dateTimeParse = (value, options) => {
  if (isDateTime(value)) {
    return value;
  }
  if (typeof value === "string") {
    return parseString(value, options);
  }
  return parseOthers(value, options);
};
const parseString = (value, options) => {
  var _a;
  const parsed = parse(value, options == null ? undefined : options.roundUp, options == null ? undefined : options.timeZone, options == null ? undefined : options.fiscalYearStartMonth);
  if (value.indexOf("now") !== -1) {
    if (!isValid(value)) {
      return dateTime();
    }
    return parsed || dateTime();
  }
  const timeZone = getTimeZone(options);
  const zone = moment.tz.zone(timeZone);
  const format = (_a = options == null ? undefined : options.format) != null ? _a : systemDateFormats.fullDate;
  if (zone && zone.name) {
    return dateTimeForTimeZone(zone.name, value, format);
  }
  if (format === systemDateFormats.fullDate) {
    return dateTime(parsed, format);
  }
  switch (lowerCase(timeZone)) {
    case "utc":
      return toUtc(value, format);
    default:
      return dateTime(value, format);
  }
};
const parseOthers = (value, options) => {
  const date = value;
  const timeZone = getTimeZone(options);
  const zone = moment.tz.zone(timeZone);
  if (zone && zone.name) {
    return dateTimeForTimeZone(zone.name, date);
  }
  switch (lowerCase(timeZone)) {
    case "utc":
      return toUtc(date);
    default:
      return dateTime(date);
  }
};

export { dateTimeParse };
//# sourceMappingURL=parser.mjs.map
