{"version":3,"file":"utils.mjs","sources":["../../../src/dataframe/utils.ts"],"sourcesContent":["import { DataFrame, Field, FieldType } from '../types/dataFrame';\n\nimport { getTimeField } from './processDataFrame';\n\nconst MAX_TIME_COMPARISONS = 100;\n\nexport function isTimeSeriesFrame(frame: DataFrame) {\n  // If we have less than two frames we can't have a timeseries\n  if (frame.fields.length < 2) {\n    return false;\n  }\n\n  // Find a number field, as long as we have any number field this should work\n  const numberField = frame.fields.find((field) => field.type === FieldType.number);\n\n  // There are certain query types in which we will\n  // get times but they will be the same or not be\n  // in increasing order. To have a time-series the\n  // times need to be ordered from past to present\n  let timeFieldFound = false;\n  for (const field of frame.fields) {\n    if (isTimeSeriesField(field)) {\n      timeFieldFound = true;\n      break;\n    }\n  }\n\n  return timeFieldFound && numberField !== undefined;\n}\n\nexport function isTimeSeriesFrames(data: DataFrame[]) {\n  return !data.find((frame) => !isTimeSeriesFrame(frame));\n}\n\n/**\n * Determines if a field is a time field in ascending\n * order within the sampling range specified by\n * MAX_TIME_COMPARISONS\n *\n * @param field\n * @returns boolean\n */\nexport function isTimeSeriesField(field: Field) {\n  if (field.type !== FieldType.time) {\n    return false;\n  }\n\n  let greatestTime: number | null = null;\n  let testWindow = field.values.length > MAX_TIME_COMPARISONS ? MAX_TIME_COMPARISONS : field.values.length;\n\n  // Test up to the test window number of values\n  for (let i = 0; i < testWindow; i++) {\n    const time = field.values[i];\n\n    // Check to see if the current time is greater than\n    // the last time. If we get to the end then we\n    // have a time series otherwise we return false\n    if (greatestTime === null || (time !== null && time > greatestTime)) {\n      greatestTime = time;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Indicates if there is any time field in the array of data frames\n * @param data\n */\nexport function anySeriesWithTimeField(data: DataFrame[]) {\n  for (let i = 0; i < data.length; i++) {\n    const timeField = getTimeField(data[i]);\n    if (timeField.timeField !== undefined && timeField.timeIndex !== undefined) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Indicates if there is any time field in the data frame\n * @param data\n */\nexport function hasTimeField(data: DataFrame): boolean {\n  return data.fields.some((field) => field.type === FieldType.time);\n}\n\n/**\n * Get row id based on the meta.uniqueRowIdFields attribute.\n * @param dataFrame\n * @param rowIndex\n */\nexport function getRowUniqueId(dataFrame: DataFrame, rowIndex: number) {\n  if (dataFrame.meta?.uniqueRowIdFields === undefined) {\n    return undefined;\n  }\n  return dataFrame.meta.uniqueRowIdFields.map((fieldIndex) => dataFrame.fields[fieldIndex].values[rowIndex]).join('-');\n}\n\n/**\n * Simple helper to add values to a data frame. Doesn't do any validation so make sure you are adding the right types\n * of values.\n * @param dataFrame\n * @param row Either an array of values or an object with keys that match the field names.\n */\nexport function addRow(dataFrame: DataFrame, row: Record<string, unknown> | unknown[]) {\n  if (row instanceof Array) {\n    for (let i = 0; i < row.length; i++) {\n      dataFrame.fields[i].values.push(row[i]);\n    }\n  } else {\n    for (const field of dataFrame.fields) {\n      field.values.push(row[field.name]);\n    }\n  }\n  try {\n    dataFrame.length++;\n  } catch (e) {\n    // Unfortunate but even though DataFrame as interface defines length some implementation of DataFrame only have\n    // length getter. In that case it will throw and so we just skip and assume they defined a `getter` for length that\n    // does not need any external updating.\n  }\n}\n"],"names":[],"mappings":"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"}