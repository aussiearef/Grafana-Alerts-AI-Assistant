{"version":3,"file":"StreamingDataFrame.mjs","sources":["../../../src/dataframe/StreamingDataFrame.ts"],"sourcesContent":["import { AlignedData } from 'uplot';\n\nimport { join } from '../transformations/transformers/joinDataFrames';\nimport { Labels, QueryResultMeta } from '../types/data';\nimport { FieldDTO, DataFrame, Field, FieldType } from '../types/dataFrame';\nimport { parseLabels } from '../utils/labels';\nimport { renderLegendFormat } from '../utils/legend';\n\nimport { DataFrameJSON, decodeFieldValueEntities, FieldSchema } from './DataFrameJSON';\nimport { guessFieldTypeFromValue, toFilteredDataFrameDTO } from './processDataFrame';\n\n/**\n * Indicate if the frame is appened or replace\n *\n * @alpha\n */\nexport enum StreamingFrameAction {\n  Append = 'append',\n  Replace = 'replace',\n}\n\n/**\n * @alpha\n * */\nexport interface StreamingFrameOptions {\n  maxLength: number; // 1000\n  maxDelta: number; // how long to keep things\n  action: StreamingFrameAction; // default will append\n\n  /** optionally format field names based on labels */\n  displayNameFormat?: string;\n}\n\n/**\n * Stream packet info is attached to StreamingDataFrames and indicate how many\n * rows were added to the end of the frame.  The number of discarded rows can be\n * calculated from previous state\n */\nexport interface StreamPacketInfo {\n  number: number;\n  action: StreamingFrameAction;\n  length: number;\n  schemaChanged: boolean;\n}\n\nconst PROM_STYLE_METRIC_LABEL = '__name__';\n\nenum PushMode {\n  wide,\n  labels,\n  // long\n}\n\nexport type SerializedStreamingDataFrame = {\n  name?: string;\n  fields: FieldDTO[];\n  refId?: string;\n  meta: QueryResultMeta;\n  schemaFields: FieldSchema[];\n  timeFieldIndex: number;\n  pushMode: PushMode;\n  length: number;\n  packetInfo: StreamPacketInfo;\n  options: StreamingFrameOptions;\n  labels: Set<string>;\n};\n\n/**\n * Unlike a circular buffer, this will append and periodically slice the front\n */\nexport class StreamingDataFrame implements DataFrame {\n  name?: string;\n  refId?: string;\n  meta: QueryResultMeta = {};\n\n  fields: Field[] = [];\n  length = 0;\n\n  private schemaFields: FieldSchema[] = [];\n  private timeFieldIndex = -1;\n  private pushMode = PushMode.wide;\n\n  // current labels\n  private labels: Set<string> = new Set();\n  readonly packetInfo: StreamPacketInfo = {\n    schemaChanged: true,\n    number: 0,\n    action: StreamingFrameAction.Replace,\n    length: 0,\n  };\n\n  private constructor(public options: StreamingFrameOptions) {\n    // Get Length to show up if you use spread\n    Object.defineProperty(this, 'length', {\n      enumerable: true,\n    });\n\n    // Get fields to show up if you use spread\n    Object.defineProperty(this, 'fields', {\n      enumerable: true,\n    });\n  }\n\n  serialize = (\n    fieldPredicate?: (f: Field) => boolean,\n    optionsOverride?: Partial<StreamingFrameOptions>,\n    trimValues?: {\n      maxLength?: number;\n    }\n  ): SerializedStreamingDataFrame => {\n    const options = optionsOverride ? Object.assign({}, { ...this.options, ...optionsOverride }) : this.options;\n    const dataFrameDTO = toFilteredDataFrameDTO(this, fieldPredicate);\n\n    const numberOfItemsToRemove = getNumberOfItemsToRemove(\n      dataFrameDTO.fields.map((f) => f.values ?? []),\n      typeof trimValues?.maxLength === 'number' ? Math.min(trimValues.maxLength, options.maxLength) : options.maxLength,\n      this.timeFieldIndex,\n      options.maxDelta\n    );\n\n    dataFrameDTO.fields = dataFrameDTO.fields.map((f) => ({\n      ...f,\n      values: f.values?.slice(numberOfItemsToRemove),\n    }));\n\n    const length = dataFrameDTO.fields[0]?.values?.length ?? 0;\n\n    return {\n      ...dataFrameDTO,\n      // TODO: Labels and schema are not filtered by field\n      labels: this.labels,\n      schemaFields: this.schemaFields,\n\n      name: this.name,\n      refId: this.refId,\n      meta: this.meta,\n      length,\n      timeFieldIndex: this.timeFieldIndex,\n      pushMode: this.pushMode,\n      packetInfo: this.packetInfo,\n      options,\n    };\n  };\n\n  private initFromSerialized = (serialized: Omit<SerializedStreamingDataFrame, 'options'>) => {\n    this.name = serialized.name;\n    this.refId = serialized.refId;\n    this.meta = serialized.meta;\n    this.length = serialized.length;\n    this.labels = serialized.labels;\n    this.schemaFields = serialized.schemaFields;\n    this.timeFieldIndex = serialized.timeFieldIndex;\n    this.pushMode = serialized.pushMode;\n    this.packetInfo.length = serialized.packetInfo.length;\n    this.packetInfo.number = serialized.packetInfo.number;\n    this.packetInfo.action = StreamingFrameAction.Replace;\n    this.packetInfo.schemaChanged = true;\n    this.fields = serialized.fields.map((f) => ({\n      ...f,\n      type: f.type ?? FieldType.other,\n      config: f.config ?? {},\n      values: f.values ?? [],\n    }));\n\n    assureValuesAreWithinLengthLimit(\n      this.fields.map((f) => f.values),\n      this.options.maxLength,\n      this.timeFieldIndex,\n      this.options.maxDelta\n    );\n  };\n\n  static deserialize = (serialized: SerializedStreamingDataFrame) => {\n    const frame = new StreamingDataFrame(serialized.options);\n    frame.initFromSerialized(serialized);\n    return frame;\n  };\n\n  static empty = (opts?: Partial<StreamingFrameOptions>): StreamingDataFrame =>\n    new StreamingDataFrame(getStreamingFrameOptions(opts));\n\n  static fromDataFrameJSON = (frame: DataFrameJSON, opts?: Partial<StreamingFrameOptions>): StreamingDataFrame => {\n    const streamingDataFrame = new StreamingDataFrame(getStreamingFrameOptions(opts));\n    streamingDataFrame.push(frame);\n    return streamingDataFrame;\n  };\n\n  private get alwaysReplace() {\n    return this.options.action === StreamingFrameAction.Replace;\n  }\n\n  needsResizing = ({ maxLength, maxDelta }: StreamingFrameOptions) => {\n    const needsMoreLength = maxLength && this.options.maxLength < maxLength;\n    const needsBiggerDelta = maxDelta && this.options.maxDelta < maxDelta;\n    const needsToOverrideDefaultInfinityDelta = maxDelta && this.options.maxDelta === Infinity;\n    return Boolean(needsMoreLength || needsBiggerDelta || needsToOverrideDefaultInfinityDelta);\n  };\n\n  resize = ({ maxLength, maxDelta }: Partial<StreamingFrameOptions>) => {\n    if (maxDelta) {\n      if (this.options.maxDelta === Infinity) {\n        this.options.maxDelta = maxDelta;\n      } else {\n        this.options.maxDelta = Math.max(maxDelta, this.options.maxDelta);\n      }\n    }\n    this.options.maxLength = Math.max(this.options.maxLength, maxLength ?? 0);\n  };\n\n  /**\n   * apply the new message to the existing data.  This will replace the existing schema\n   * if a new schema is included in the message, or append data matching the current schema\n   */\n  push(msg: DataFrameJSON): StreamPacketInfo {\n    const { schema, data } = msg;\n\n    this.packetInfo.number++;\n    this.packetInfo.length = 0;\n    this.packetInfo.schemaChanged = false;\n\n    if (schema) {\n      this.pushMode = PushMode.wide;\n      this.timeFieldIndex = schema.fields.findIndex((f) => f.type === FieldType.time);\n      const firstField = schema.fields[0];\n      if (\n        this.timeFieldIndex === 1 &&\n        firstField.type === FieldType.string &&\n        (firstField.name === 'labels' || firstField.name === 'Labels')\n      ) {\n        this.pushMode = PushMode.labels;\n        this.timeFieldIndex = 0; // after labels are removed!\n      }\n\n      const niceSchemaFields = this.pushMode === PushMode.labels ? schema.fields.slice(1) : schema.fields;\n\n      this.refId = schema.refId;\n      if (schema.meta) {\n        this.meta = { ...schema.meta };\n      }\n\n      const { displayNameFormat } = this.options;\n      if (hasSameStructure(this.schemaFields, niceSchemaFields)) {\n        const len = niceSchemaFields.length;\n        this.fields.forEach((f, idx) => {\n          const sf = niceSchemaFields[idx % len];\n          f.config = sf.config ?? {};\n          f.labels = sf.labels;\n        });\n        if (displayNameFormat) {\n          this.fields.forEach((f) => {\n            const labels = { [PROM_STYLE_METRIC_LABEL]: f.name, ...f.labels };\n            f.config.displayNameFromDS = renderLegendFormat(displayNameFormat, labels);\n          });\n        }\n      } else {\n        this.packetInfo.schemaChanged = true;\n        const isWide = this.pushMode === PushMode.wide;\n        this.fields = niceSchemaFields.map((f) => {\n          const config = f.config ?? {};\n          if (displayNameFormat) {\n            const labels = { [PROM_STYLE_METRIC_LABEL]: f.name, ...f.labels };\n            config.displayNameFromDS = renderLegendFormat(displayNameFormat, labels);\n          }\n          return {\n            config,\n            name: f.name,\n            labels: f.labels,\n            type: f.type ?? FieldType.other,\n            // transfer old values by type & name, unless we relied on labels to match fields\n            values: isWide\n              ? (this.fields.find((of) => of.name === f.name && f.type === of.type)?.values ??\n                Array(this.length).fill(undefined))\n              : [],\n          };\n        });\n      }\n\n      this.schemaFields = niceSchemaFields;\n    }\n\n    if (data && data.values.length && data.values[0].length) {\n      let { values, entities } = data;\n\n      if (entities) {\n        entities.forEach((ents, i) => {\n          if (ents) {\n            decodeFieldValueEntities(ents, values[i]);\n            // TODO: append replacements to field\n          }\n        });\n      }\n\n      if (this.pushMode === PushMode.labels) {\n        // augment and transform data to match current schema for standard circPush() path\n        const labeledTables = transpose(values);\n\n        // make sure fields are initalized for each label\n        for (const label of labeledTables.keys()) {\n          if (!this.labels.has(label)) {\n            this.packetInfo.schemaChanged = true;\n            this.addLabel(label);\n          }\n        }\n\n        // TODO: cache higher up\n        let dummyTable = Array(this.schemaFields.length).fill([]);\n\n        let tables: AlignedData[] = [];\n        this.labels.forEach((label) => {\n          tables.push(labeledTables.get(label) ?? dummyTable);\n        });\n\n        values = join(tables);\n      }\n\n      if (values.length !== this.fields.length) {\n        if (this.fields.length) {\n          throw new Error(\n            `push message mismatch.  Expected: ${this.fields.length}, received: ${values.length} (labels=${\n              this.pushMode === PushMode.labels\n            })`\n          );\n        }\n\n        this.fields = values.map((vals, idx) => {\n          let name = `Field ${idx}`;\n          let type = guessFieldTypeFromValue(vals[0]);\n          const isTime = idx === 0 && type === FieldType.number && (vals as number[])[0] > 1600016688632;\n          if (isTime) {\n            type = FieldType.time;\n            name = 'Time';\n          }\n\n          return {\n            name,\n            type,\n            config: {},\n            values: [],\n          };\n        });\n      }\n\n      let appended = values;\n      this.packetInfo.length = values[0].length;\n\n      if (this.alwaysReplace || !this.length) {\n        this.packetInfo.action = StreamingFrameAction.Replace;\n      } else {\n        this.packetInfo.action = StreamingFrameAction.Append;\n\n        // mutates appended\n        appended = this.fields.map((f) => f.values);\n        circPush(appended, values, this.options.maxLength, this.timeFieldIndex, this.options.maxDelta);\n      }\n\n      appended.forEach((v, i) => {\n        const field = this.fields[i];\n        const { state } = field;\n        field.values = v;\n        if (state) {\n          state.calcs = undefined;\n        }\n      });\n\n      // Update the frame length\n      this.length = appended[0].length;\n    }\n\n    return {\n      ...this.packetInfo,\n    };\n  }\n\n  pushNewValues = (values: unknown[][]) => {\n    if (!values?.length) {\n      return;\n    }\n\n    this.packetInfo.action = this.options.action;\n    this.packetInfo.number++;\n    this.packetInfo.length = values[0].length;\n    this.packetInfo.schemaChanged = false;\n\n    if (this.options.action === StreamingFrameAction.Append) {\n      circPush(\n        this.fields.map((f) => f.values),\n        values,\n        this.options.maxLength,\n        this.timeFieldIndex,\n        this.options.maxDelta\n      );\n    } else {\n      values.forEach((v, i) => {\n        if (this.fields[i]) {\n          this.fields[i].values = v;\n        }\n      });\n\n      assureValuesAreWithinLengthLimit(\n        this.fields.map((f) => f.values),\n        this.options.maxLength,\n        this.timeFieldIndex,\n        this.options.maxDelta\n      );\n    }\n    const newLength = this.fields?.[0]?.values.length;\n    if (newLength !== undefined) {\n      this.length = newLength;\n    }\n  };\n\n  resetStateCalculations = () => {\n    this.fields.forEach((f) => {\n      f.state = {\n        ...(f.state ?? {}),\n        calcs: undefined,\n        range: undefined,\n      };\n    });\n  };\n\n  getMatchingFieldIndexes = (fieldPredicate: (f: Field) => boolean): number[] =>\n    this.fields\n      .map((f, index) => (fieldPredicate(f) ? index : undefined))\n      .filter((val) => val !== undefined) as number[];\n\n  getValuesFromLastPacket = (): unknown[][] =>\n    this.fields.map((f) => {\n      const values = f.values;\n      return values.slice(Math.max(values.length - this.packetInfo.length));\n    });\n\n  hasAtLeastOnePacket = () => Boolean(this.packetInfo.length);\n\n  // adds a set of fields for a new label\n  private addLabel(label: string) {\n    const { displayNameFormat } = this.options;\n    const labelCount = this.labels.size;\n\n    // parse labels\n    const parsedLabels = parseLabelsFromField(label);\n\n    if (labelCount === 0) {\n      // mutate existing fields and add labels\n      this.fields.forEach((f, i) => {\n        if (i > 0) {\n          f.labels = parsedLabels;\n          if (displayNameFormat) {\n            const labels = { [PROM_STYLE_METRIC_LABEL]: f.name, ...parsedLabels };\n            f.config.displayNameFromDS = renderLegendFormat(displayNameFormat, labels);\n          }\n        }\n      });\n    } else {\n      for (let i = 1; i < this.schemaFields.length; i++) {\n        let proto = this.schemaFields[i] as Field;\n        const config = proto.config ?? {};\n        if (displayNameFormat) {\n          const labels = { [PROM_STYLE_METRIC_LABEL]: proto.name, ...parsedLabels };\n          config.displayNameFromDS = renderLegendFormat(displayNameFormat, labels);\n        }\n        this.fields.push({\n          ...proto,\n          config,\n          labels: parsedLabels,\n          values: Array(this.length).fill(undefined),\n        });\n      }\n    }\n\n    this.labels.add(label);\n  }\n\n  getOptions = (): Readonly<StreamingFrameOptions> => this.options;\n}\n\nexport function getStreamingFrameOptions(opts?: Partial<StreamingFrameOptions>): StreamingFrameOptions {\n  return {\n    maxLength: opts?.maxLength ?? 1000,\n    maxDelta: opts?.maxDelta ?? Infinity,\n    action: opts?.action ?? StreamingFrameAction.Append,\n    displayNameFormat: opts?.displayNameFormat,\n  };\n}\n\n// converts vertical insertion records with table keys in [0] and column values in [1...N]\n// to join()-able tables with column arrays\nexport function transpose(vrecs: unknown[][]) {\n  let tableKeys = new Set(vrecs[0]);\n  let tables = new Map();\n\n  tableKeys.forEach((key) => {\n    let cols = Array(vrecs.length - 1)\n      .fill(null)\n      .map(() => []);\n\n    tables.set(key, cols);\n  });\n\n  for (let r = 0; r < vrecs[0].length; r++) {\n    let table = tables.get(vrecs[0][r]);\n    for (let c = 1; c < vrecs.length; c++) {\n      table[c - 1].push(vrecs[c][r]);\n    }\n  }\n\n  return tables;\n}\n\n// binary search for index of closest value\nexport function closestIdx(num: number, arr: number[], lo?: number, hi?: number) {\n  let mid;\n  lo = lo || 0;\n  hi = hi || arr.length - 1;\n  let bitwise = hi <= 2147483647;\n\n  while (hi - lo > 1) {\n    mid = bitwise ? (lo + hi) >> 1 : Math.floor((lo + hi) / 2);\n\n    if (arr[mid] < num) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n\n  if (num - arr[lo] <= arr[hi] - num) {\n    return lo;\n  }\n\n  return hi;\n}\n\nexport function parseLabelsFromField(str: string): Labels {\n  if (!str.length) {\n    return {};\n  }\n  if (str.charAt(0) === '{') {\n    return parseLabels(str);\n  }\n  const parsedLabels: Labels = {};\n  str.split(',').forEach((kv) => {\n    const [key, val] = kv.trim().split('=');\n    parsedLabels[key] = val;\n  });\n  return parsedLabels;\n}\n\n/**\n * @internal // not exported in yet\n */\nexport function getLastStreamingDataFramePacket(frame: DataFrame) {\n  if (frame instanceof StreamingDataFrame) {\n    const pi = frame.packetInfo;\n    return pi.action;\n  }\n  return undefined;\n}\n\n// mutable circular push\nfunction circPush(data: unknown[][], newData: unknown[][], maxLength = Infinity, deltaIdx = 0, maxDelta = Infinity) {\n  for (let i = 0; i < data.length; i++) {\n    for (let k = 0; k < newData[i].length; k++) {\n      data[i].push(newData[i][k]);\n    }\n  }\n\n  return assureValuesAreWithinLengthLimit(data, maxLength, deltaIdx, maxDelta);\n}\n\nfunction assureValuesAreWithinLengthLimit(data: unknown[][], maxLength = Infinity, deltaIdx = 0, maxDelta = Infinity) {\n  const count = getNumberOfItemsToRemove(data, maxLength, deltaIdx, maxDelta);\n\n  if (count) {\n    for (let i = 0; i < data.length; i++) {\n      data[i].splice(0, count);\n    }\n  }\n\n  return count;\n}\n\nfunction getNumberOfItemsToRemove(data: unknown[][], maxLength = Infinity, deltaIdx = 0, maxDelta = Infinity) {\n  if (!data[0]?.length) {\n    return 0;\n  }\n\n  const nlen = data[0].length;\n\n  let sliceIdx = 0;\n\n  if (nlen > maxLength) {\n    sliceIdx = nlen - maxLength;\n  }\n\n  if (maxDelta !== Infinity && deltaIdx >= 0) {\n    const deltaLookup = data[deltaIdx] as number[];\n\n    const low = deltaLookup[sliceIdx];\n    const high = deltaLookup[nlen - 1];\n\n    if (high - low > maxDelta) {\n      sliceIdx = closestIdx(high - maxDelta, deltaLookup, sliceIdx);\n    }\n  }\n\n  return sliceIdx;\n}\n\nfunction hasSameStructure(a: FieldSchema[], b: FieldSchema[]): boolean {\n  if (a?.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    const fA = a[i];\n    const fB = b[i];\n    if (fA.name !== fB.name || fA.type !== fB.type) {\n      return false;\n    }\n  }\n  return true;\n}\n"],"names":["StreamingFrameAction","_a"],"mappings":"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"}