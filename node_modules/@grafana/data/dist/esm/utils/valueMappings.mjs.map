{"version":3,"file":"valueMappings.mjs","sources":["../../../src/utils/valueMappings.ts"],"sourcesContent":["import { getActiveThreshold } from '../field/thresholds';\nimport { stringToJsRegex } from '../text/string';\nimport { ThresholdsConfig } from '../types/thresholds';\nimport {\n  MappingType,\n  SpecialValueMatch,\n  SpecialValueOptions,\n  ValueMap,\n  ValueMapping,\n  ValueMappingResult,\n} from '../types/valueMapping';\n\nexport function getValueMappingResult(valueMappings: ValueMapping[], value: any): ValueMappingResult | null {\n  for (const vm of valueMappings) {\n    switch (vm.type) {\n      case MappingType.ValueToText:\n        if (value == null) {\n          continue;\n        }\n\n        const result = vm.options[value];\n        if (result) {\n          return result;\n        }\n\n        break;\n\n      case MappingType.RangeToText:\n        if (value == null) {\n          continue;\n        }\n\n        const valueAsNumber = parseFloat(value);\n        if (isNaN(valueAsNumber)) {\n          continue;\n        }\n\n        const isNumFrom = !isNaN(vm.options.from!);\n        if (isNumFrom && valueAsNumber < vm.options.from!) {\n          continue;\n        }\n\n        const isNumTo = !isNaN(vm.options.to!);\n        if (isNumTo && valueAsNumber > vm.options.to!) {\n          continue;\n        }\n\n        return vm.options.result;\n\n      case MappingType.RegexToText:\n        if (value == null) {\n          continue;\n        }\n\n        if (typeof value !== 'string') {\n          continue;\n        }\n\n        const regex = stringToJsRegex(vm.options.pattern);\n        if (value.match(regex)) {\n          const res = { ...vm.options.result };\n\n          if (res.text != null) {\n            res.text = value.replace(regex, vm.options.result.text || '');\n          }\n\n          return res;\n        }\n\n      case MappingType.SpecialValue:\n        switch ((vm.options as SpecialValueOptions).match) {\n          case SpecialValueMatch.Null: {\n            if (value == null) {\n              return vm.options.result;\n            }\n            break;\n          }\n          case SpecialValueMatch.NaN: {\n            if (typeof value === 'number' && isNaN(value)) {\n              return vm.options.result;\n            }\n            break;\n          }\n          case SpecialValueMatch.NullAndNaN: {\n            if ((typeof value === 'number' && isNaN(value)) || value == null) {\n              return vm.options.result;\n            }\n            break;\n          }\n          case SpecialValueMatch.True: {\n            if (value === true || value === 'true') {\n              return vm.options.result;\n            }\n            break;\n          }\n          case SpecialValueMatch.False: {\n            if (value === false || value === 'false') {\n              return vm.options.result;\n            }\n            break;\n          }\n          case SpecialValueMatch.Empty: {\n            if (value === '') {\n              return vm.options.result;\n            }\n            break;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// Ref https://stackoverflow.com/a/58550111\nexport function isNumeric(num: unknown) {\n  return (typeof num === 'number' || (typeof num === 'string' && num.trim() !== '')) && !isNaN(num as number);\n}\n\n/**\n * @deprecated use MappingType instead\n * @internal\n */\nexport enum LegacyMappingType {\n  ValueToText = 1,\n  RangeToText = 2,\n}\n\n/**\n * @alpha\n * Converts the old Angular value mappings to new react style\n */\nexport function convertOldAngularValueMappings(panel: any, migratedThresholds?: ThresholdsConfig): ValueMapping[] {\n  const mappings: ValueMapping[] = [];\n\n  // Guess the right type based on options\n  let mappingType = panel.mappingType;\n  if (!panel.mappingType) {\n    if (panel.valueMaps && panel.valueMaps.length) {\n      mappingType = 1;\n    } else if (panel.rangeMaps && panel.rangeMaps.length) {\n      mappingType = 2;\n    }\n  }\n  if (mappingType === 1) {\n    for (let i = 0; i < panel.valueMaps.length; i++) {\n      const map = panel.valueMaps[i];\n      mappings.push(\n        upgradeOldAngularValueMapping(\n          {\n            ...map,\n            id: i, // used for order\n            type: MappingType.ValueToText,\n          },\n          panel.fieldConfig?.defaults?.thresholds || migratedThresholds\n        )\n      );\n    }\n  } else if (mappingType === 2) {\n    for (let i = 0; i < panel.rangeMaps.length; i++) {\n      const map = panel.rangeMaps[i];\n      mappings.push(\n        upgradeOldAngularValueMapping(\n          {\n            ...map,\n            id: i, // used for order\n            type: MappingType.RangeToText,\n          },\n          panel.fieldConfig?.defaults?.thresholds || migratedThresholds\n        )\n      );\n    }\n  }\n\n  return mappings;\n}\n\nfunction upgradeOldAngularValueMapping(old: any, thresholds?: ThresholdsConfig): ValueMapping {\n  const valueMaps: ValueMap = { type: MappingType.ValueToText, options: {} };\n  const newMappings: ValueMapping[] = [];\n\n  // Use the color we would have picked from thesholds\n  let color: string | undefined = undefined;\n  const numeric = parseFloat(old.text);\n  if (thresholds && !isNaN(numeric)) {\n    const level = getActiveThreshold(numeric, thresholds.steps);\n    if (level && level.color) {\n      color = level.color;\n    }\n  }\n\n  switch (old.type) {\n    case LegacyMappingType.ValueToText:\n    case MappingType.ValueToText:\n      if (old.value != null) {\n        if (old.value === 'null') {\n          newMappings.push({\n            type: MappingType.SpecialValue,\n            options: {\n              match: SpecialValueMatch.Null,\n              result: { text: old.text, color },\n            },\n          });\n        } else {\n          valueMaps.options[String(old.value)] = {\n            text: old.text,\n            color,\n          };\n        }\n      }\n      break;\n    case LegacyMappingType.RangeToText:\n    case MappingType.RangeToText:\n      if (old.from === 'null' || old.to === 'null') {\n        newMappings.push({\n          type: MappingType.SpecialValue,\n          options: {\n            match: SpecialValueMatch.Null,\n            result: { text: old.text, color },\n          },\n        });\n      } else {\n        newMappings.push({\n          type: MappingType.RangeToText,\n          options: {\n            from: +old.from,\n            to: +old.to,\n            result: { text: old.text, color },\n          },\n        });\n      }\n      break;\n  }\n\n  if (Object.keys(valueMaps.options).length > 0) {\n    newMappings.unshift(valueMaps);\n  }\n\n  return newMappings[0];\n}\n"],"names":["LegacyMappingType"],"mappings":"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"}