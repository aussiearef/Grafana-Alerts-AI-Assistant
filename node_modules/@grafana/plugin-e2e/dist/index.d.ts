import * as _playwright_test from '@playwright/test';
import { Locator, Request, Response as Response$1, APIRequestContext, TestInfo, PlaywrightTestArgs, PlaywrightTestOptions, PlaywrightWorkerArgs, PlaywrightWorkerOptions, MatcherReturnType } from '@playwright/test';
export { selectors } from '@playwright/test';
import * as playwright_core from 'playwright-core';
import { SelectorsOf, versionedPages, versionedComponents } from '@grafana/e2e-selectors';

/**
 * Base class for all Grafana pages.
 *
 * Exposes methods for locating Grafana specific elements on the page
 */
declare abstract class GrafanaPage {
    readonly ctx: PluginTestCtx;
    readonly pageArgs: GrafanaPageArgs;
    constructor(ctx: PluginTestCtx, pageArgs?: GrafanaPageArgs);
    protected navigate(url: string, options?: NavigateOptions): Promise<void>;
    /**
     * Get a locator based on a Grafana E2E selector. A grafana E2E selector is defined in @grafana/e2e-selectors or in plugin-e2e/src/e2e-selectors.
     * An E2E selector is a string that identifies a specific element in the Grafana UI. The element referencing the E2E selector use the data-testid or aria-label attribute.
     */
    getByGrafanaSelector(selector: string, options?: getByGrafanaSelectorOptions): Locator;
    /**
     * Mocks the response of the datasource query call
     * @param json the json response to return
     * @param status the HTTP status code to return. Defaults to 200
     */
    mockQueryDataResponse<T = any>(json: T, status?: number): Promise<void>;
    /**
     * Mocks the response of the datasource resource request.
     * https://grafana.com/developers/plugin-tools/key-concepts/backend-plugins#resources
     *
     * @param path the path of the resource to mock
     * @param json the json response to return
     * @param status the HTTP status code to return. Defaults to 200
     */
    mockResourceResponse<T = any>(path: string, json: T, status?: number): Promise<void>;
    /**
     * Waits for a data source query data request to be made.
     *
     * @param cb optional callback to filter the request. Use this to filter by request body or other request properties
     */
    waitForQueryDataRequest(cb?: (request: Request) => boolean | Promise<boolean>): Promise<Request>;
    /**
     * Waits for a data source query data response
     *
     * @param cb optional callback to filter the response. Use this to filter by response body or other response properties
     */
    waitForQueryDataResponse(cb?: (request: Response$1) => boolean | Promise<boolean>): Promise<Response$1>;
}

declare class DataSourcePicker extends GrafanaPage {
    private root?;
    constructor(ctx: PluginTestCtx, root?: Locator | undefined);
    /**
     * Sets the data source picker to the provided name
     */
    set(name: string): Promise<void>;
}

declare class AnnotationEditPage extends GrafanaPage {
    readonly ctx: PluginTestCtx;
    readonly args: DashboardEditViewArgs<string>;
    datasource: DataSourcePicker;
    constructor(ctx: PluginTestCtx, args: DashboardEditViewArgs<string>);
    /**
     * Navigates to the annotation edit page. If a dashboard uid was not provided, it's assumed that it's a new dashboard.
     */
    goto(options?: NavigateOptions): Promise<void>;
    /**
     * Executes the annotation query defined in the annotation page and returns the response promise
     * @param options - Optional. RequestOptions to pass to waitForResponse
     */
    runQuery(options?: RequestOptions): Promise<playwright_core.Response>;
}

declare class PluginConfigPage extends GrafanaPage {
    readonly ctx: PluginTestCtx;
    readonly args: PluginPageArgs;
    constructor(ctx: PluginTestCtx, args: PluginPageArgs);
    /**
     * Navigates to the app plugin config page.
     */
    goto(options?: NavigateOptions): Promise<void>;
}

declare class AppConfigPage extends PluginConfigPage {
    readonly ctx: PluginTestCtx;
    readonly args: PluginPageArgs;
    constructor(ctx: PluginTestCtx, args: PluginPageArgs);
    /**
     * Will wait for the settings endpoint to be called e.g. when saving settings
     */
    waitForSettingsResponse(options?: {
        timeout?: number;
    }): Promise<Response$1>;
}

declare class AppPage extends GrafanaPage {
    readonly ctx: PluginTestCtx;
    readonly args: PluginPageArgs;
    constructor(ctx: PluginTestCtx, args: PluginPageArgs);
    /**
     * Will append the `/a/${pluginId}` before the provided path and then
     * navigate to the page.
     */
    goto(options?: AppPageNavigateOptions): Promise<void>;
}

declare class TimeRange extends GrafanaPage {
    constructor(ctx: PluginTestCtx);
    /**
     * Opens the time picker and sets the time range to the provided values
     */
    set({ from, to, zone }: TimeRangeArgs): Promise<void>;
}

declare class Panel extends GrafanaPage {
    readonly ctx: PluginTestCtx;
    readonly locator: Locator;
    constructor(ctx: PluginTestCtx, locator: Locator);
    /**
     * Returns a locator that resolves element(s) that contain the field name(s) that are currently displayed in the panel.
     *
     * Can be used to assert the field names displayed in the panel visualization. e.g
     * await expect(panelEditPage.panel.fieldNames).toHaveValues(['Month', 'Stockholm', 'Berlin', 'Log Angeles']);
     */
    get fieldNames(): Locator;
    /**
     * Returns a locator that resolves element(s) that contain the value(s) that are currently displayed in the panel.
     *
     * Can be used to assert the values displayed in the panel visualization. e.g
     * await expect(panelEditPage.panel.data).toContainText(['1', '4', '14']);
     */
    get data(): Locator;
    /**
     * Click on a menu item in the panel menu.
     *
     * Pass options.parentItem to specify the parent item of the menu item to click.
     */
    clickOnMenuItem(item: string, options?: {
        parentItem?: string;
    }): Promise<void>;
    /**
     * Returns the locator for the panel error (if any)
     */
    getErrorIcon(): Locator;
}

type LocatorParams = Parameters<Locator['locator']>;
declare abstract class ComponentBase {
    readonly ctx: PluginTestCtx;
    protected readonly element: Locator;
    constructor(ctx: PluginTestCtx, element: Locator);
    locator(selectorOrLocator?: LocatorParams[0], options?: LocatorParams[1]): Locator;
}

type SelectOptionsType = Parameters<Locator['selectOption']>[1];
type CheckOptionsType = Parameters<Locator['check']>[0];

declare class ColorPicker extends ComponentBase {
    constructor(ctx: PluginTestCtx, element: Locator);
    selectOption(rgbOrHex: string, options?: SelectOptionsType): Promise<void>;
    private getCustomTab;
    private getContainer;
}

declare class UnitPicker extends ComponentBase {
    constructor(ctx: PluginTestCtx, element: Locator);
    selectOption(value: string, options?: SelectOptionsType): Promise<void>;
    private getOption;
}

declare class Select extends ComponentBase {
    constructor(ctx: PluginTestCtx, element: Locator);
    selectOption(values: string, options?: SelectOptionsType): Promise<string>;
}

declare class MultiSelect extends ComponentBase {
    constructor(ctx: PluginTestCtx, element: Locator);
    selectOptions(values: string[], options?: SelectOptionsType): Promise<string[]>;
}

declare class Switch extends ComponentBase {
    private group;
    constructor(ctx: PluginTestCtx, group: Locator);
    private static getElement;
    check(options?: CheckOptionsType): Promise<void>;
    uncheck(options?: CheckOptionsType): Promise<void>;
    private getSwitch;
}

declare class RadioGroup extends ComponentBase {
    constructor(ctx: PluginTestCtx, element: Locator);
    check(labelOrValue: string, options?: CheckOptionsType): Promise<void>;
}

declare class PanelEditOptionsGroup {
    private ctx;
    readonly element: Locator;
    private groupLabel;
    constructor(ctx: PluginTestCtx, element: Locator, groupLabel: string);
    isExpanded(): Promise<boolean>;
    collapse(): Promise<void>;
    expand(): Promise<void>;
    getRadioGroup(label: string): RadioGroup;
    getSwitch(label: string): Switch;
    getTextInput(label: string): Locator;
    getNumberInput(label: string): Locator;
    getSliderInput(label: string): Locator;
    getSelect(label: string): Select;
    getMultiSelect(label: string): MultiSelect;
    getColorPicker(label: string): ColorPicker;
    getUnitPicker(label: string): UnitPicker;
    private getByLabel;
    private getOptionsGroupToggle;
}

declare class PanelEditPage extends GrafanaPage {
    readonly ctx: PluginTestCtx;
    readonly args: DashboardEditViewArgs<string>;
    datasource: DataSourcePicker;
    timeRange: TimeRange;
    panel: Panel;
    constructor(ctx: PluginTestCtx, args: DashboardEditViewArgs<string>);
    private getPanelLocator;
    /**
     * Navigates to the panel edit page. If a dashboard uid was not provided, it's assumed that it's a new dashboard.
     */
    goto(options?: NavigateOptions): Promise<void>;
    toggleTableView(): Promise<void>;
    untoggleTableView(): Promise<void>;
    /**
     * Sets the title of the panel. This method will open the panel options, set the title and close the panel options.
     */
    setPanelTitle(titleText: string): Promise<void>;
    /**
     * Sets the visualization for the panel. This method will open the visualization picker, select the given visualization
     */
    setVisualization(visualization: Visualization | string): Promise<void>;
    /**
     * Expands the section for the given category name. If the section is already expanded, this method does nothing.
     * @deprecated use {@link PanelEditOptionsGroup.expand} method instead.
     */
    collapseSection(categoryName: string): Promise<void>;
    /**
     * Returns the name of the visualization currently selected in the panel editor
     */
    getVisualizationName(): Locator;
    /**
     * Clicks the "Back to dashboard" button in the panel editor
     * In versions prior to 11.3.0, this method clicks the "Apply" button instead
     */
    backToDashboard(): Promise<DashboardPage>;
    /**
     * Clicks the "Apply" button in the panel editor
     *
     * @deprecated use {@link PanelEditPage.backToDashboard} method instead.
     */
    apply(): Promise<DashboardPage>;
    /**
     * Returns the locator for the query editor row with the given refId
     */
    getQueryEditorRow(refId: string): Locator;
    /**
     * Clicks the "Refresh" button in the panel editor. Returns the response promise for the data query
     *
     * By default, this method will wait for any response that has the url '/api/ds/query'.
     * If you need to wait for a specific response, you can pass a callback to the `waitForResponsePredicateCallback` option.
     * e.g
     * panelEditPage.refreshPanel({
        waitForResponsePredicateCallback: (r) =>
          r.url().includes(selectors.apis.DataSource.query) &&
          r.body().then((body) => body.includes(`"status":"finished"`)),
      })
     */
    refreshPanel(options?: RequestOptions): Promise<Response$1>;
    /** Return page object for the panel edit options group with the given label */
    getCustomOptions(label: string): PanelEditOptionsGroup;
    getPanelOptions(): PanelEditOptionsGroup;
    getStandardOptions(): PanelEditOptionsGroup;
    getValueMappingOptions(): PanelEditOptionsGroup;
    getDataLinksOptions(): PanelEditOptionsGroup;
    getThresholdsOptions(): PanelEditOptionsGroup;
    private getOptionsGroupLocator;
}

declare class DashboardPage extends GrafanaPage {
    readonly ctx: PluginTestCtx;
    readonly dashboard?: DashboardPageArgs | undefined;
    dataSourcePicker: any;
    timeRange: TimeRange;
    constructor(ctx: PluginTestCtx, dashboard?: DashboardPageArgs | undefined);
    /**
     * Navigates to the dashboard page. If a dashboard uid was not provided, it's assumed that it's a new dashboard.
     */
    goto(options?: NavigateOptions): Promise<void>;
    /**
     * Navigates to the panel edit page for the given panel id
     *
     * If the panel id does not exist in the dashboard, Grafana will redirect to the dashboard page
     */
    gotoPanelEditPage(panelId: string): Promise<PanelEditPage>;
    /**
     * Returns a Panel object for the panel with the given title. Only works for panels that currently are in the viewport.
     *
     * Note that this won't navigate to the panel edit page, it will only return the Panel object, which
     * points to the locator for the panel in the dashboard page. Can be used to assert on the panel data, eg.
     * const panel = await dashboardPage.getPanelByTitle('Table panel');
     * await expect(panel.fieldNames).toContainText(['time', 'temperature']);
     */
    getPanelByTitle(title: string): Panel;
    /**
     * Returns a Panel object for the panel with the given id. Only works for panels that currently are in the viewport.
     *
     * Note that this won't navigate to the panel edit page, it will only return the Panel object, which
     * points to the locator for the panel in the dashboard page. Can be used to assert on the panel data, eg.
     * const panel = await dashboardPage.getPanelByTitle('2');
     * await expect(panel.fieldNames()).toContainText(['time', 'temperature']);
     */
    getPanelById(panelId: string): Panel;
    /**
     * Clicks the buttons to add a new panel and returns the panel edit page for the new panel
     */
    addPanel(): Promise<PanelEditPage>;
    /**
     * Deletes the dashboard
     */
    deleteDashboard(): Promise<void>;
    /**
     * Clicks the run button in the refresh picker to refresh the dashboard
     */
    refreshDashboard(): Promise<void>;
}

declare class DataSourceConfigPage extends GrafanaPage {
    datasource: DataSourceSettings;
    constructor(ctx: PluginTestCtx, datasource: DataSourceSettings);
    deleteDataSource(): Promise<void>;
    /**
     * Navigates to the datasource edit page for an existing datasource
     */
    goto(options?: NavigateOptions): Promise<void>;
    /**
     * Mocks the response of the datasource health check call
     * @param json the json response to return
     * @param status the HTTP status code to return. Defaults to 200
     */
    mockHealthCheckResponse<T = any>(json: T, status?: number): Promise<void>;
    /**
     * Clicks the save and test button and waits for the response
     *
     * By default, this will return the response of the health check call to /api/datasources/uid/<pluginUid>/health.
     * Optionally, if your plugin uses a custom health check endpoint, you can provide the {@link TriggerRequestOptions.path } of this url.
     * May be useful for data source plugins that don't have a backend.
     */
    saveAndTest(options?: TriggerRequestOptions): Promise<Response$1>;
}

declare class ExplorePage extends GrafanaPage {
    readonly args?: GrafanaPageArgs | undefined;
    datasource: DataSourcePicker;
    timeRange: any;
    timeSeriesPanel: Panel;
    tablePanel: Panel;
    constructor(ctx: PluginTestCtx, args?: GrafanaPageArgs | undefined);
    private getPanelLocators;
    /**
     * Navigates to the explore page.
     */
    goto(options?: NavigateOptions): Promise<void>;
    /**
     * Returns the locator for the query editor row with the given refId
     */
    getQueryEditorRow(refId: string): Locator;
    /**
     * Clicks the "Run Query" button in the refresh picker to run the query. Returns the response promise for the data query
     */
    runQuery(options?: RequestOptions): Promise<_playwright_test.Response>;
}

type VariableType = 'Query' | 'Constant' | 'Custom';
declare class VariableEditPage extends GrafanaPage {
    readonly ctx: PluginTestCtx;
    readonly args: DashboardEditViewArgs<string>;
    datasource: DataSourcePicker;
    constructor(ctx: PluginTestCtx, args: DashboardEditViewArgs<string>);
    /**
     * Navigates to the variable edit page. If a dashboard uid was not provided, it's assumed that it's a new dashboard.
     */
    goto(options?: NavigateOptions): Promise<void>;
    /**
     * Sets the type of variable in the 'Variable type' dropdown to the given type
     */
    setVariableType(type: VariableType): Promise<void>;
    /**
     * Triggers the variable query to run. Note that unlike {@link PanelEditPage.refreshPanel}, this method doesn't
     * return a request promise. This is because there's no canonical way of querying variables - data sources may
     * call any endpoint or resolve variables in the frontend. If you need to wait for a specific request, you can
     * do that in your test.
     * @example await this.ctx.page.waitForResponse((resp) => resp.url().includes('<url>')
     */
    runQuery(): Promise<void>;
}

declare class VariablePage extends GrafanaPage {
    readonly ctx: PluginTestCtx;
    readonly dashboard?: DashboardPageArgs | undefined;
    constructor(ctx: PluginTestCtx, dashboard?: DashboardPageArgs | undefined);
    /**
     * Navigates to the variable list page. If a dashboard uid was not provided, it's assumed that it's a new dashboard.
     */
    goto(options?: NavigateOptions): Promise<void>;
    /**
     * Clicks the add new variable button and returns the variable edit page
     */
    clickAddNew(): Promise<VariableEditPage>;
}

declare class AlertRuleQuery extends GrafanaPage {
    readonly ctx: PluginTestCtx;
    readonly locator: Locator;
    datasource: DataSourcePicker;
    constructor(ctx: PluginTestCtx, locator: Locator);
    getByGrafanaSelector(selector: string, options?: getByGrafanaSelectorOptions): Locator;
}

declare class AlertRuleEditPage extends GrafanaPage {
    readonly ctx: PluginTestCtx;
    readonly args?: AlertRuleArgs | undefined;
    constructor(ctx: PluginTestCtx, args?: AlertRuleArgs | undefined);
    /**
     * Navigates to the annotation edit page. If a dashboard uid was not provided, it's assumed that it's a new dashboard.
     */
    goto(options?: NavigateOptions): Promise<void>;
    /**
     * Returns a locator for hte alert rule name field
     */
    get alertRuleNameField(): playwright_core.Locator;
    get advancedModeSwitch(): playwright_core.Locator;
    isAdvancedModeSupported(): Promise<boolean>;
    enableAdvancedQueryMode(): Promise<void>;
    disableAdvancedQueryMode(): Promise<void>;
    getQueryRow(refId?: string): Promise<AlertRuleQuery>;
    /**
     * @deprecated Use getQueryRow instead
     * Returns an instance of the {@link AlertRuleQuery} class for a query in the query and expression step (step 2)
     *
     * @param refId is optional. If not provided, it will return query row with refId 'A' in Grafana versions <11.6.
     * In Grafana versions >=11.6 where advanced mode is supported, it will return the default query if advanced mode
     * is not enabled. If advanced mode is enabled, it will return the a query by refId.
     */
    getAlertRuleQueryRow(refId?: string): AlertRuleQuery;
    /**
     * Clicks the "Add query" button and returns an instance of the {@link AlertRuleQuery} class for the new query row.
     *
     * Since Grafana 11.6, this method is only available if advanced mode is enabled. Use enableQueryAdvancedMode() method to enable it.
     */
    clickAddQueryRow(): Promise<AlertRuleQuery>;
    /**
     * Clicks the evaluate button and waits for the evaluation to complete. If the evaluation is successful, the status code of the response is 200.
     * If one or more queries are invalid, an error status code is returned.
     *
     * Note that this method intercepts the response of the alerting evaluation endpoint and returns the status code of the first failed query.
     * This means that any mocks defined with page.route in your tests will be overriden.
     *
     * Only supported for Grafana version 9.5.0 ad later.
     */
    evaluate(options?: RequestOptions): Promise<playwright_core.Response>;
}

declare class GrafanaAPIClient {
    private request;
    constructor(request: APIRequestContext);
    getUserIdByUsername(userName: string): Promise<any>;
    createUser(user: User): Promise<void>;
    getDataSourceSettingsByUID(uid: string): Promise<DataSourceSettings<{}, {}>>;
    createDataSource(datasource: CreateDataSourceArgs, dsName: string): Promise<_playwright_test.APIResponse>;
    getDataSourceByName(name: string): Promise<_playwright_test.APIResponse>;
    deleteDataSourceByUID(uid: string): Promise<_playwright_test.APIResponse>;
}

declare const versionedAPIs: {
    Alerting: {
        eval: {
            "8.0.0": string;
        };
    };
    DataSource: {
        resourcePattern: {
            "8.0.0": string;
        };
        resourceUIDPattern: {
            '9.4.4': string;
            "8.0.0": string;
        };
        queryPattern: {
            "8.0.0": string;
        };
        query: {
            "8.0.0": string;
        };
        health: {
            '9.4.0': (uid: string, _: string) => string;
            "8.0.0": (_: string, id: string) => string;
        };
        datasourceByUID: {
            "8.0.0": (uid: string) => string;
        };
        proxy: {
            '9.4.0': (uid: string, _: string) => string;
            "8.0.0": (_: string, id: string) => string;
        };
    };
    Dashboard: {
        delete: {
            "8.0.0": (uid: string) => string;
        };
    };
    Plugin: {
        settings: {
            "8.0.0": (pluginId: string) => string;
        };
    };
};
type VersionedAPIs = typeof versionedAPIs;

declare const versionedConstants: {
    PageToolBar: {
        itemButtonTitle: {
            '10.1.0': string;
            "8.0.0": string;
        };
    };
    Select: {
        singleValueContainer: {
            "8.0.0": () => string;
        };
        multiValueContainer: {
            "8.0.0": () => string;
        };
    };
    Cascader: {
        menu: {
            "8.0.0": () => string;
        };
    };
};
type VersionedConstants = typeof versionedConstants;

type PluginOptions = {
    /**
     * When using the readProvisioning fixture, files will be read from this directory. If no directory is provided,
     * the 'provisioning' directory in the current working directory will be used.
     *
     * eg.
     * export default defineConfig({
        use: {
          provisioningRootDir: 'path/to/provisioning',
        },
      });
     *
     */
    provisioningRootDir: string;
    /**
     * Optionally, you can add or override feature toggles.
     * The feature toggles you specify here will only work in the frontend. If you need a feature toggle to work across the entire stack, you
     * need to need to enable the feature in the Grafana config. Also see https://grafana.com/developers/plugin-tools/e2e-test-a-plugin/feature-toggles
     *
     * To override feature toggles globally in the playwright.config.ts file:
     * export default defineConfig({
        use: {
          featureToggles: {
            exploreMixedDatasource: true,
            redshiftAsyncQueryDataSupport: false
          },
        },
      });
     *
     * To override feature toggles for tests in a certain file:
       test.use({
        featureToggles: {
          exploreMixedDatasource: true,
        },
     * });
     */
    featureToggles: Record<string, boolean>;
    /**
     * The Grafana user to use for the tests. If no user is provided, the default admin/admin user will be used.
     *
     * You can use different users for different projects. See the fixture createUser for more information on how to create a user,
     * and the fixture login for more information on how to authenticate. Also see https://grafana.com/developers/plugin-tools/e2e-test-a-plugin/use-authentication
     */
    user?: User;
    /**
     * The credentials to use when making requests to the Grafana API. For example when creating users, fetching data sources etc.
     * If no credentials are provided, the server default admin:admin credentials will be used.
     */
    grafanaAPICredentials: Credentials;
};
type PluginFixture = {
    /**
     * The Grafana version that was detected when the test runner was started.
     *
     * If a GRAFANA_VERSION environment variable is set, this will be used. Otherwise,
     * the version will be picked from window.grafanaBootData.settings.buildInfo.version.
     */
    grafanaVersion: string;
    /**
     * The E2E selectors to use for the current version of Grafana.
     * See https://grafana.com/developers/plugin-tools/e2e-test-a-plugin/selecting-elements#grafana-end-to-end-selectors for more information.
     */
    selectors: E2ESelectorGroups;
    /**
     * Fixture command that creates a data source via the Grafana API.
     *
     * If you have tests that depend on the the existance of a data source,
     * you may use this command in a setup project. Read more about setup projects
     * here: https://playwright.dev/docs/auth#basic-shared-account-in-all-tests
     */
    createDataSource: (args: CreateDataSourceArgs) => Promise<DataSourceSettings>;
    /**
     * Fixture command that creates a user via the Grafana API and assigns a role to it if a role is provided
     * This may be useful if your plugin supports RBAC and you need to create a user with a specific role. See login fixture for more information.
     */
    createUser: () => Promise<void>;
    /**
     * Fixture command that login to Grafana using the Grafana API and stores the cookie state on disk.
     * The file name for the storage state will be `playwright/.auth/<username>.json`, so it's important that the username is unique.
     *
     * If you have not specified a user, the default admin/admin credentials will be used.
     *
     * e.g
     * projects: [
        {
          name: 'authenticate',
          testDir: './src/auth',
          testMatch: [/.*auth\.setup\.ts/],
        },
        {
          name: 'run tests as admin user',
          testDir: './tests',
          use: {
            ...devices['Desktop Chrome'],
            storageState: 'playwright/.auth/admin.json',
          },
          dependencies: ['authenticate'],
        }
      }
     *
     * If your plugin supports RBAC, you may want to use different projects for different roles.
     * In the following example, a new user with the role `Viewer` gets created and authenticated in a `createUserAndAuthenticate` project.
     * In the `viewer` project, authentication state from the previous project is used in all tests in the ./tests/viewer folder.
     * projects: [
        {
          name: 'createUserAndAuthenticate',
          testDir: 'node_modules/@grafana/plugin-e2e/dist/auth',
          testMatch: [/.*auth\.setup\.ts/],
          use: {
            user: {
              user: 'viewer',
              password: 'password',
              role: 'Viewer',
            },
          },
        },
        {
          name: 'viewer',
          testDir: './tests/viewer',
          use: {
            ...devices['Desktop Chrome'],
            storageState: 'playwright/.auth/viewer.json',
          },
          dependencies: ['createUserAndAuthenticate'],
        }
      }
     *
     * To override credentials in a single test:
     * test.use({ storageState: 'playwright/.auth/admin.json', user: { user: 'admin', password: 'admin' } });
     * To avoid authentication in a single test:
     * test.use({ storageState: { cookies: [], origins: [] } });
     */
    login: () => Promise<void>;
    /**
     * Fixture command that reads a yaml file in the provisioning/datasources directory.
     *
     * The file name should be the name of the file with the .yaml|.yml extension.
     * If a data source name is provided, the first data source that matches the name will be returned.
     * If no name is provided, the first data source in the list of data sources will be returned.
     */
    readProvisionedDataSource<T = {}, S = {}>(args: ReadProvisionedDataSourceArgs): Promise<DataSourceSettings<T, S>>;
    /**
     * Fixture command that reads a yaml file in the provisioning/alerting directory.
     *
     * The file name should be the name of the file with the .yaml|.yml extension.
     * If a group name is provided, the first group that matches the name will be returned.
     * If no group name is provided, the first group in the list of groups will be returned.
     * If a rule title is provided, the first rule that matches the title will be returned.
     * If no rule title is provided, the first rule in the group will be returned.
     */
    readProvisionedAlertRule(args: ReadProvisionedAlertRuleArgs): Promise<AlertRule>;
    /**
     * Fixture command that reads a dashboard json file in the provisioning/dashboards directory.
     *
     * Can be useful when navigating to a provisioned dashboard and you don't want to hard code the dashboard UID.
     */
    readProvisionedDashboard(args: ReadProvisionedDashboardArgs): Promise<Dashboard>;
    /**
     * Function that checks if a feature toggle is enabled. Only works for frontend feature toggles.
     */
    isFeatureToggleEnabled<T = object>(featureToggle: keyof T): Promise<boolean>;
    /**
     * Client that allows you to use certain endpoints in the Grafana http API.
     *
     The GrafanaAPIClient doesn't call the Grafana HTTP API on behalf of the logged in user -
     * it uses the {@link types.grafanaAPICredentials} credentials. grafanaAPICredentials defaults to admin:admin, but you may override this
     * by specifying grafanaAPICredentials in the playwright config options.
     *
     * Note that storage state for the admin client is not persisted throughout the test suite. For every test where the grafanaAPICredentials fixtures is used,
     * new storage state is created.
     */
    grafanaAPIClient: GrafanaAPIClient;
    /**
     * Isolated {@link DashboardPage} instance for each test.
     *
     * When using this fixture in a test, you will get a new, empty dashboard page.
     * To load an existing dashboard, use the {@link gotoDashboardPage} fixture.
     */
    dashboardPage: DashboardPage;
    /**
     * Isolated {@link PanelEditPage} instance for each test.
     *
     * Navigates to a new dashboard page and adds a new panel.
     *
     * When using this fixture in a test, you will get a new dashboard page with a new empty panel edit page
     * To load an existing dashboard with an existing panel, use the {@link gotoPanelEditPage} fixture.
     */
    panelEditPage: PanelEditPage;
    /**
     * Isolated {@link VariableEditPage} instance for each test.
     *
     * When using this fixture in a test, you will get a new dashboard page with a new empty variable edit page
     * To load an existing dashboard with an existing variable, use the {@link gotoVariableEditPage} fixture.
     */
    variableEditPage: VariableEditPage;
    /**
     * Isolated {@link VariablePage} instance for each test.
     *
     * When using this fixture in a test, you will get a new dashboard page with a new empty variable edit page
     * To load an existing dashboard with an existing variable, use the {@link gotoVariableEditPage} fixture.
     */
    variablePage: VariablePage;
    /**
     * Isolated {@link AnnotationEditPage} instance for each test.
     *
     * When using this fixture in a test, you will get a new dashboard page with a new empty annotation edit page
     * To load an existing dashboard with an existing annotation, use the {@link gotoAnnotationEditPage} fixture.
     */
    annotationEditPage: AnnotationEditPage;
    /**
     * Isolated {@link AlertRuleEditPage} instance for each test.
     *
     * When using this fixture in a test, you will get an empty alert rule page form
     * To load an existing alert rule, use the {@link gotoAlertRulePage} fixture.
     */
    alertRuleEditPage: AlertRuleEditPage;
    /**
     * Isolated {@link ExplorePage} instance for each test.
     */
    explorePage: ExplorePage;
    /**
     * Fixture command that will create an isolated DataSourceConfigPage instance for a given data source type.
     *
     * The data source config page cannot be navigated to without a data source uid, so this fixture will create a new
     * data source using the Grafana API, create a new DataSourceConfigPage instance and navigate to the page.
     */
    createDataSourceConfigPage: (args: CreateDataSourcePageArgs) => Promise<DataSourceConfigPage>;
    /**
     * Fixture command that navigates to an already exist dashboard. Returns a DashboardPage instance.
     */
    gotoDashboardPage: (args: DashboardPageArgs) => Promise<DashboardPage>;
    /**
     * Fixture command that navigates a panel edit page for an already existing panel in a dashboard.
     */
    gotoPanelEditPage: (args: DashboardEditViewArgs<string>) => Promise<PanelEditPage>;
    /**
     * Fixture command that navigates a variable edit page for an already existing variable query in a dashboard.
     */
    gotoVariableEditPage: (args: DashboardEditViewArgs<string>) => Promise<VariableEditPage>;
    /**
     * Fixture command that navigates a variable edit page for an already existing variable query in a dashboard.
     */
    gotoVariablePage: (args: DashboardPageArgs) => Promise<VariablePage>;
    /**
     * Fixture command that navigates an annotation edit page for an already existing annotation query in a dashboard.
     */
    gotoAnnotationEditPage: (args: DashboardEditViewArgs<string>) => Promise<AnnotationEditPage>;
    /**
     * Fixture command that navigates to an alert rule edit page for an already existing alert query.
     */
    gotoAlertRuleEditPage: (args: AlertRuleArgs) => Promise<AlertRuleEditPage>;
    /**
     * Fixture command that navigates a configuration page for an already existing data source instance.
     */
    gotoDataSourceConfigPage: (uid: string) => Promise<DataSourceConfigPage>;
    /**
     * Fixture command that navigates to the AppConfigPage for a given plugin.
     */
    gotoAppConfigPage: (args: GotoAppConfigPageArgs) => Promise<AppConfigPage>;
    /**
     * Fixture command that navigates to an AppPage for a given plugin.
     */
    gotoAppPage: (args: GotoAppPageArgs) => Promise<AppPage>;
};
/**
 * The context object passed to page object models
 */
type PluginTestCtx = {
    grafanaVersion: string;
    selectors: E2ESelectorGroups;
    testInfo: TestInfo;
} & Pick<PlaywrightTestArgs, 'page' | 'request'>;
/**
 * Playwright args used when defining fixtures
 */
type PlaywrightArgs = PluginFixture & PluginOptions & PlaywrightTestArgs & PlaywrightTestOptions & PlaywrightWorkerArgs & PlaywrightWorkerOptions;
/**
 * The data source settings
 */
interface DataSourceSettings<T = {}, S = {}> {
    id: number;
    editable?: boolean;
    uid: string;
    orgId?: number;
    name: string;
    type: string;
    access?: string;
    url?: string;
    database?: string;
    isDefault?: boolean;
    jsonData: T;
    secureJsonData?: S;
}
interface AlertRule {
    uid: string;
    title: string;
    data: Array<{
        refId: string;
        datasourceUid: string;
        model: any;
    }>;
}
/**
 * The dashboard object
 */
interface Dashboard {
    uid: string;
    title?: string;
}
type User = {
    /**
     * The username of the user
     */
    user: string;
    password: string;
    role?: OrgRole;
};
type Credentials = {
    /**
     * The username of the user
     */
    user: string;
    password: string;
};
type CreateDataSourceArgs<T = any> = {
    /**
     * The data source to create
     */
    id?: number;
    editable?: boolean;
    uid?: string;
    orgId?: number;
    name?: string;
    type: string;
    access?: string;
    url?: string;
    database?: string;
    isDefault?: boolean;
    jsonData?: T;
    secureJsonData?: T;
};
type CreateDataSourcePageArgs = {
    /**
     * The data source type to create. This corresponds to the unique id of the data source plugin (`id` in `plugin.json`).
     */
    type: string;
    /**
     * The data source name to create
     */
    name?: string;
    /**
     * Set this to false to delete the data source via Grafana API after the test. Defaults to true.
     */
    deleteDataSourceAfterTest?: boolean;
};
interface TimeRangeArgs {
    /**
     * The from time
     * @example 'now-6h'
     * @example '2020-01-01 00:00:00'
     */
    from: string;
    /**
     * The to time
     * @example 'now'
     * @example '2020-01-01 00:00:00'
     */
    to: string;
    /**
     * The time zone
     * @example 'utc'
     * @example 'browser'
     */
    zone?: string;
}
type GrafanaPageArgs = NavigateOptions;
type DashboardPageArgs = GrafanaPageArgs & {
    /**
     * The uid of the dashboard to go to
     */
    uid?: string;
    /**
     * The time range to set
     */
    timeRange?: TimeRangeArgs;
    /**
     * Query parameters to add to the url
     */
    queryParams?: URLSearchParams;
};
/**
 * DashboardEditViewArgs is used to pass arguments to the page object models that represent a dashboard edit view,
 * such as {@link PanelEditPage}, {@link VariableEditPage} and {@link AnnotationEditPage}.
 *
 * If dashboard is not specified, it's assumed that it's a new dashboard. Otherwise, the dashboard uid is used to
 * navigate to an already existing dashboard.
 */
type DashboardEditViewArgs<T> = GrafanaPageArgs & {
    dashboard?: DashboardPageArgs;
    id: T;
};
type AlertRuleArgs = GrafanaPageArgs & {
    uid: string;
};
type ReadProvisionedDashboardArgs = {
    /**
     * The path, relative to the provisioning folder, to the dashboard json file
     */
    fileName: string;
};
type ReadProvisionedAlertRuleArgs = {
    /**
     * The name of the yaml file in the provisioning/alerting folder
     */
    fileName: string;
    /**
     * The name of the alert group in the groups list. Will use the first group if not provided
     */
    groupName?: string;
    /**
     * The name of the alert rule in the rules list. Will use the first rule in the group if not provided
     */
    ruleTitle?: string;
};
type ReadProvisionedDataSourceArgs = {
    /**
     * The name of the yaml file in the provisioning/datasources folder
     */
    fileName: string;
    /**
     * The name of the data source in the datasources list. Will use the first data source if not provided
     */
    name?: string;
};
type PluginPageArgs = GrafanaPageArgs & {
    pluginId: string;
};
type GotoAppConfigPageArgs = PluginPageArgs;
type GotoAppPageArgs = PluginPageArgs & {
    path?: string;
};
type RequestOptions = {
    /**
     * Maximum wait time in milliseconds, defaults to 30 seconds, pass `0` to disable the timeout. The default value can
     * be changed by using the
     * [browserContext.setDefaultTimeout(timeout)](https://playwright.dev/docs/api/class-browsercontext#browser-context-set-default-timeout)
     * or [page.setDefaultTimeout(timeout)](https://playwright.dev/docs/api/class-page#page-set-default-timeout) methods.
     */
    timeout?: number;
    waitForResponsePredicateCallback?: string | RegExp | ((response: Response$1) => boolean | Promise<boolean>);
};
type NavigateOptions = {
    /**
     * Referer header value.
     */
    referer?: string;
    /**
     * Maximum operation time in milliseconds. Defaults to `0` - no timeout.
     */
    timeout?: number;
    /**
     * When to consider operation succeeded, defaults to `load`. Events can be either:
     * - `'domcontentloaded'` - consider operation to be finished when the `DOMContentLoaded` event is fired.
     * - `'load'` - consider operation to be finished when the `load` event is fired.
     * - `'networkidle'` - **DISCOURAGED** consider operation to be finished when there are no network connections for
     *   at least `500` ms. Don't use this method for testing, rely on web assertions to assess readiness instead.
     * - `'commit'` - consider operation to be finished when network response is received and the document started
     *   loading.
     */
    waitUntil?: 'load' | 'domcontentloaded' | 'networkidle' | 'commit';
    /**
     * Query parameters to add to the url. Optional
     */
    queryParams?: URLSearchParams;
};
type AppPageNavigateOptions = NavigateOptions & {
    path?: string;
};
type getByGrafanaSelectorOptions = {
    /**
     *Optional root locator to search within. If no locator is provided, the page will be used
     */
    root?: Locator;
    /**
     * Set to true to find locator that resolves elements that starts with a given string
     * Defaults to false
     */
    startsWith?: boolean;
};
type TriggerRequestOptions = {
    /**
     * The path to the endpoint to trigger
     */
    path?: string;
};
interface ContainTextOptions {
    /**
     * Whether to perform case-insensitive match. `ignoreCase` option takes precedence over the corresponding regular
     * expression flag if specified.
     */
    ignoreCase?: boolean;
    /**
     * Time to retry the assertion for in milliseconds. Defaults to `timeout` in `TestConfig.expect`.
     */
    timeout?: number;
    /**
     * Whether to use `element.innerText` instead of `element.textContent` when retrieving DOM node text.
     */
    useInnerText?: boolean;
}
interface AlertPageOptions {
    /**
     * Maximum wait time in milliseconds, defaults to 30 seconds, pass `0` to disable the timeout. The default value can
     * be changed by using the
     * [browserContext.setDefaultTimeout(timeout)](https://playwright.dev/docs/api/class-browsercontext#browser-context-set-default-timeout)
     * or [page.setDefaultTimeout(timeout)](https://playwright.dev/docs/api/class-page#page-set-default-timeout) methods.
     */
    timeout?: number;
    /**
     * Matches elements containing an element that matches an inner locator. Inner locator is queried against the outer
     * one. For example, `article` that has `text=Playwright` matches `<article><div>Playwright</div></article>`.
     *
     * Note that outer and inner locators must belong to the same frame. Inner locator must not contain {@link
     * FrameLocator}s.
     */
    has?: Locator;
    /**
     * Matches elements that do not contain an element that matches an inner locator. Inner locator is queried against the
     * outer one. For example, `article` that does not have `div` matches `<article><span>Playwright</span></article>`.
     *
     * Note that outer and inner locators must belong to the same frame. Inner locator must not contain {@link
     * FrameLocator}s.
     */
    hasNot?: Locator;
    /**
     * Matches elements that do not contain specified text somewhere inside, possibly in a child or a descendant element.
     * When passed a [string], matching is case-insensitive and searches for a substring.
     */
    hasNotText?: string | RegExp;
    /**
     * Matches elements containing specified text somewhere inside, possibly in a child or a descendant element. When
     * passed a [string], matching is case-insensitive and searches for a substring. For example, `"Playwright"` matches
     * `<article><div>Playwright</div></article>`.
     */
    hasText?: string | RegExp;
}
type OrgRole = 'None' | 'Viewer' | 'Editor' | 'Admin';
/**
 * Panel visualization types
 */
type Visualization = 'Alert list' | 'Bar gauge' | 'Clock' | 'Dashboard list' | 'Gauge' | 'Graph' | 'Heatmap' | 'Logs' | 'News' | 'Pie Chart' | 'Plugin list' | 'Polystat' | 'Stat' | 'Table' | 'Text' | 'Time series' | 'Worldmap Panel';
type AlertVariant$1 = 'success' | 'warning' | 'error' | 'info';
type E2ESelectorGroups = {
    constants: SelectorsOf<VersionedConstants>;
    apis: SelectorsOf<VersionedAPIs>;
    pages: SelectorsOf<typeof versionedPages>;
    components: SelectorsOf<typeof versionedComponents>;
};

type AlertVariant = 'success' | 'warning' | 'error' | 'info';

declare function toHaveSelected(target: Select | MultiSelect | UnitPicker, value: string | RegExp | string[] | RegExp[], options?: ContainTextOptions): Promise<MatcherReturnType>;

declare function toBeChecked(target: Switch | Locator, options?: {
    checked?: boolean;
    timeout?: number;
}): Promise<MatcherReturnType>;

declare function toHaveChecked(radioGroup: RadioGroup, expected: string, options?: {
    timeout?: number;
}): Promise<MatcherReturnType>;

declare function toHaveColor(colorPicker: ColorPicker, rgbOrHex: string, options?: {
    timeout?: number;
}): Promise<MatcherReturnType>;

declare class AnnotationPage extends GrafanaPage {
    readonly ctx: PluginTestCtx;
    readonly dashboard?: DashboardPageArgs | undefined;
    constructor(ctx: PluginTestCtx, dashboard?: DashboardPageArgs | undefined);
    /**
     * Navigates to the annotation list page. If a dashboard uid was not provided, it's assumed that it's a new dashboard.
     */
    goto(options?: NavigateOptions): Promise<void>;
    /**
     * Clicks the add new annotation button and returns the annotation edit page
     */
    clickAddNew(): Promise<AnnotationEditPage>;
}

declare const test: _playwright_test.TestType<_playwright_test.PlaywrightTestArgs & _playwright_test.PlaywrightTestOptions & PluginFixture, _playwright_test.PlaywrightWorkerArgs & _playwright_test.PlaywrightWorkerOptions & PluginOptions>;
declare const expect: _playwright_test.Expect<{
    toHaveAlert: (grafanaPage: GrafanaPage, severity: AlertVariant, options?: AlertPageOptions) => Promise<{
        message: () => any;
        pass: boolean;
    }>;
    toDisplayPreviews: (variableEditPage: VariableEditPage, previewTexts: Array<string | RegExp>, options?: ContainTextOptions) => Promise<{
        pass: boolean;
        actual: boolean;
        message: () => string;
    } | {
        message: () => string;
        pass: boolean;
        actual: undefined;
    }>;
    toBeOK: (request: Promise<_playwright_test.Response>) => Promise<{
        message: () => string;
        pass: boolean;
        actual: number;
    } | {
        message: () => string;
        pass: boolean;
        actual: undefined;
    }>;
    toHaveSelected: typeof toHaveSelected;
    toBeChecked: typeof toBeChecked;
    toHaveChecked: typeof toHaveChecked;
    toHaveColor: typeof toHaveColor;
}>;

declare global {
    interface Window {
        monaco: any;
        grafanaBootData: {
            settings: {
                featureToggles: Record<string, boolean>;
            };
        };
    }
    namespace PlaywrightTest {
        const r: unique symbol;
        const t: unique symbol;
        interface Matchers<R, T> {
            [r]: R;
            [t]: T;
            /**
             * Await the response of a Playwright request and asserts the response was successful (status in the range 200-299).
             */
            toBeOK(this: Matchers<unknown, Promise<Response>>): R;
            /**
             * Asserts that preview text elements are displayed on the Variable Edit Page. You should make sure any variable queries are completed before calling this matcher.
             */
            toDisplayPreviews(this: Matchers<unknown, VariableEditPage>, previewTexts: Array<string | RegExp>, options: ContainTextOptions): R;
            /**
             * Asserts that a GrafanaPage contains an alert with the specified severity. Use the options to specify the timeout and to filter the alerts.
             */
            toHaveAlert(this: Matchers<unknown, GrafanaPage>, severity: AlertVariant$1, options?: AlertPageOptions): Promise<R>;
            /**
             * Asserts that a Selector has the specified value selected
             */
            toHaveSelected(select: Select | MultiSelect, value: string | RegExp | string[] | RegExp[], options?: ContainTextOptions): Promise<R>;
            /**
             * Asserts that a Switch is on or off (on by default)
             */
            toBeChecked(target: Switch | Locator, options?: {
                on?: boolean;
                timeout?: number;
            }): Promise<R>;
            /**
             * Asserts that a Radio has expected value selected
             */
            toHaveChecked(radioGroup: RadioGroup, expected: string, options?: {
                timeout?: number;
            }): Promise<R>;
            /**
             * Asserts that a color picker has expected color selected
             */
            toHaveColor(colorPicker: ColorPicker, rgbOrHex: string, options?: {
                timeout?: number;
            }): Promise<R>;
        }
    }
}

export { AnnotationEditPage, AnnotationPage, AppConfigPage, AppPage, DashboardPage, DataSourceConfigPage, DataSourcePicker, ExplorePage, GrafanaPage, Panel, PanelEditPage, PluginConfigPage, TimeRange, VariableEditPage, VariablePage, expect, test };
export type { AlertPageOptions, AlertRule, AlertRuleArgs, AlertVariant$1 as AlertVariant, AppPageNavigateOptions, ContainTextOptions, CreateDataSourceArgs, CreateDataSourcePageArgs, Credentials, Dashboard, DashboardEditViewArgs, DashboardPageArgs, DataSourceSettings, E2ESelectorGroups, GotoAppConfigPageArgs, GotoAppPageArgs, GrafanaPageArgs, NavigateOptions, OrgRole, PlaywrightArgs, PluginFixture, PluginOptions, PluginPageArgs, PluginTestCtx, ReadProvisionedAlertRuleArgs, ReadProvisionedDashboardArgs, ReadProvisionedDataSourceArgs, RequestOptions, TimeRangeArgs, TriggerRequestOptions, User, Visualization, getByGrafanaSelectorOptions };
