'use strict';

var semver = require('semver');
var GrafanaPage = require('./GrafanaPage.js');
var AlertRuleQuery = require('../components/AlertRuleQuery.js');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var semver__namespace = /*#__PURE__*/_interopNamespaceDefault(semver);

const QUERY_AND_EXPRESSION_STEP_ID = "2";
class AlertRuleEditPage extends GrafanaPage.GrafanaPage {
  constructor(ctx, args) {
    super(ctx, args);
    this.ctx = ctx;
    this.args = args;
  }
  /**
   * Navigates to the annotation edit page. If a dashboard uid was not provided, it's assumed that it's a new dashboard.
   */
  async goto(options) {
    const { AddAlertRule, EditAlertRule } = this.ctx.selectors.pages.Alerting;
    const url = this.args?.uid ? EditAlertRule.url(this.args.uid) : AddAlertRule.url;
    return super.navigate(url, options);
  }
  /**
   * Returns a locator for hte alert rule name field
   */
  get alertRuleNameField() {
    if (semver__namespace.gte(this.ctx.grafanaVersion, "11.1.0")) {
      return this.getByGrafanaSelector(this.ctx.selectors.components.AlertRules.ruleNameField);
    }
    return this.ctx.page.getByPlaceholder("Give your alert rule a name");
  }
  get advancedModeSwitch() {
    return this.getByGrafanaSelector(
      this.ctx.selectors.components.AlertRules.stepAdvancedModeSwitch(QUERY_AND_EXPRESSION_STEP_ID)
    );
  }
  async isAdvancedModeSupported() {
    const count = await this.getByGrafanaSelector(
      this.ctx.selectors.components.AlertRules.stepAdvancedModeSwitch(QUERY_AND_EXPRESSION_STEP_ID)
    ).count();
    return count > 0;
  }
  /*
   * Enables the advanced mode for the query and expression step.
   * Only available in Grafana 11.6.0 and later. If advanced mode is not supported, this method will do nothing.
   */
  async enableAdvancedQueryMode() {
    const advancedModeSupported = await this.isAdvancedModeSupported();
    if (!advancedModeSupported) {
      console.log("Advanced query mode is not supported in this Grafana version. Ignoring the request.");
      return;
    }
    await this.getByGrafanaSelector(
      this.ctx.selectors.components.AlertRules.stepAdvancedModeSwitch(QUERY_AND_EXPRESSION_STEP_ID)
    ).check({ force: true });
  }
  /*
   * Disabled the advanced mode for the query and expression step.
   * Advanced mode is enabled by default in Grafana 11.6.0 and later.
   */
  async disableAdvancedQueryMode() {
    const advancedModeSupported = await this.isAdvancedModeSupported();
    if (!advancedModeSupported) {
      console.log("Advanced query mode is not supported in this Grafana version. Ignoring the request.");
      return;
    }
    await this.getByGrafanaSelector(
      this.ctx.selectors.components.AlertRules.stepAdvancedModeSwitch(QUERY_AND_EXPRESSION_STEP_ID)
    ).uncheck({ force: true });
  }
  async getQueryRow(refId = "A") {
    const advancedModeSupported = await this.isAdvancedModeSupported();
    if (advancedModeSupported && !await this.advancedModeSwitch.isChecked() && refId === "A") {
      return new AlertRuleQuery.AlertRuleQuery(this.ctx, this.ctx.page.getByTestId("query-editor-row"));
    }
    const locator = this.getByGrafanaSelector(this.ctx.selectors.components.QueryEditorRows.rows).filter({
      has: this.getByGrafanaSelector(this.ctx.selectors.components.QueryEditorRow.title(refId))
    });
    return new AlertRuleQuery.AlertRuleQuery(this.ctx, locator);
  }
  /**
   * @deprecated Use getQueryRow instead
   * Returns an instance of the {@link AlertRuleQuery} class for a query in the query and expression step (step 2)
   *
   * @param refId is optional. If not provided, it will return query row with refId 'A' in Grafana versions <11.6.
   * In Grafana versions >=11.6 where advanced mode is supported, it will return the default query if advanced mode
   * is not enabled. If advanced mode is enabled, it will return the a query by refId.
   */
  getAlertRuleQueryRow(refId = "A") {
    const locator = this.getByGrafanaSelector(this.ctx.selectors.components.QueryEditorRows.rows).filter({
      has: this.getByGrafanaSelector(this.ctx.selectors.components.QueryEditorRow.title(refId))
    });
    return new AlertRuleQuery.AlertRuleQuery(this.ctx, locator);
  }
  /**
   * Clicks the "Add query" button and returns an instance of the {@link AlertRuleQuery} class for the new query row.
   *
   * Since Grafana 11.6, this method is only available if advanced mode is enabled. Use enableQueryAdvancedMode() method to enable it.
   */
  async clickAddQueryRow() {
    const advancedModeSupported = await this.isAdvancedModeSupported();
    if (advancedModeSupported && !await this.advancedModeSwitch.isChecked()) {
      throw new Error(
        "Since Grafana 11.6, you need to enable advanced mode to add queries. Use enableQueryAdvancedMode() method to enable it."
      );
    }
    await this.getByGrafanaSelector(this.ctx.selectors.components.QueryTab.addQuery).click();
    const locator = this.getByGrafanaSelector(this.ctx.selectors.components.QueryEditorRows.rows).last();
    return new AlertRuleQuery.AlertRuleQuery(this.ctx, locator);
  }
  /**
   * Clicks the evaluate button and waits for the evaluation to complete. If the evaluation is successful, the status code of the response is 200.
   * If one or more queries are invalid, an error status code is returned.
   *
   * Note that this method intercepts the response of the alerting evaluation endpoint and returns the status code of the first failed query.
   * This means that any mocks defined with page.route in your tests will be overriden.
   *
   * Only supported for Grafana version 9.5.0 ad later.
   */
  async evaluate(options) {
    await this.ctx.page.waitForTimeout(1e3);
    if (semver__namespace.gte(this.ctx.grafanaVersion, "10.0.0")) {
      this.ctx.page.route(this.ctx.selectors.apis.Alerting.eval, async (route) => {
        const response = await route.fetch();
        if (!response.ok()) {
          return route.fulfill({ response });
        }
        let body = await response.json();
        const statuses = Object.keys(body.results).map((key) => body.results[key].status);
        route.fulfill({
          response,
          status: statuses.every((status) => status >= 200 && status < 300) ? 200 : statuses[0]
        });
      });
    }
    const responsePromise = this.ctx.page.waitForResponse(
      (resp) => resp.url().includes(this.ctx.selectors.apis.Alerting.eval),
      options
    );
    let evaluateButton = this.getByGrafanaSelector(this.ctx.selectors.components.AlertRules.previewButton);
    if (semver__namespace.lt(this.ctx.grafanaVersion, "11.1.0")) {
      evaluateButton = this.ctx.page.getByRole("button", { name: "Preview", exact: true });
    }
    const evalReq = this.ctx.page.waitForRequest((req) => req.url().includes(this.ctx.selectors.apis.Alerting.eval), {
      timeout: 5e3
    }).catch(async () => {
      await evaluateButton.click();
    });
    await evaluateButton.click();
    await evalReq;
    return responsePromise;
  }
}

exports.AlertRuleEditPage = AlertRuleEditPage;
