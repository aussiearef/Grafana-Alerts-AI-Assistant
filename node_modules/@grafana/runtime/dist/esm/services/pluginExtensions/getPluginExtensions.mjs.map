{"version":3,"file":"getPluginExtensions.mjs","sources":["../../../../src/services/pluginExtensions/getPluginExtensions.ts"],"sourcesContent":["import type { PluginExtension, PluginExtensionLink, PluginExtensionComponent } from '@grafana/data';\n\nimport { isPluginExtensionComponent, isPluginExtensionLink } from './utils';\n\nexport type GetPluginExtensions<T = PluginExtension> = (\n  options: GetPluginExtensionsOptions\n) => GetPluginExtensionsResult<T>;\n\nexport type UsePluginExtensions<T = PluginExtension> = (\n  options: GetPluginExtensionsOptions\n) => UsePluginExtensionsResult<T>;\n\nexport type GetPluginExtensionsOptions = {\n  extensionPointId: string;\n  // Make sure this object is properly memoized and not mutated.\n  context?: object | Record<string | symbol, unknown>;\n  limitPerPlugin?: number;\n};\n\nexport type GetPluginExtensionsResult<T = PluginExtension> = {\n  extensions: T[];\n};\n\nexport type UsePluginExtensionsResult<T = PluginExtension> = {\n  extensions: T[];\n  isLoading: boolean;\n};\n\nlet singleton: GetPluginExtensions | undefined;\n\nexport function setPluginExtensionGetter(instance: GetPluginExtensions): void {\n  // We allow overriding the registry in tests\n  if (singleton && process.env.NODE_ENV !== 'test') {\n    throw new Error('setPluginExtensionGetter() function should only be called once, when Grafana is starting.');\n  }\n  singleton = instance;\n}\n\nfunction getPluginExtensionGetter(): GetPluginExtensions {\n  if (!singleton) {\n    throw new Error('getPluginExtensionGetter() can only be used after the Grafana instance has started.');\n  }\n  return singleton;\n}\n\nexport const getPluginExtensions: GetPluginExtensions = (options) => getPluginExtensionGetter()(options);\n\nexport const getPluginLinkExtensions: GetPluginExtensions<PluginExtensionLink> = (options) => {\n  const { extensions } = getPluginExtensions(options);\n\n  return {\n    extensions: extensions.filter(isPluginExtensionLink),\n  };\n};\n\n// This getter doesn't support the `context` option (contextual information can be passed in as component props)\nexport const getPluginComponentExtensions = <Props = {}>(options: {\n  extensionPointId: string;\n  limitPerPlugin?: number;\n}): { extensions: Array<PluginExtensionComponent<Props>> } => {\n  const { extensions } = getPluginExtensions(options);\n  const componentExtensions = extensions.filter(isPluginExtensionComponent) as Array<PluginExtensionComponent<Props>>;\n\n  return {\n    extensions: componentExtensions,\n  };\n};\n"],"names":[],"mappings":";;AA4BA,IAAI,SAAA;AAEG,SAAS,yBAAyB,QAAqC,EAAA;AAE5E,EAAA,IAAI,SAAa,IAAA,OAAA,CAAQ,GAAI,CAAA,QAAA,KAAa,MAAQ,EAAA;AAChD,IAAM,MAAA,IAAI,MAAM,2FAA2F,CAAA;AAAA;AAE7G,EAAY,SAAA,GAAA,QAAA;AACd;AAEA,SAAS,wBAAgD,GAAA;AACvD,EAAA,IAAI,CAAC,SAAW,EAAA;AACd,IAAM,MAAA,IAAI,MAAM,qFAAqF,CAAA;AAAA;AAEvG,EAAO,OAAA,SAAA;AACT;AAEO,MAAM,mBAA2C,GAAA,CAAC,OAAY,KAAA,wBAAA,GAA2B,OAAO;AAE1F,MAAA,uBAAA,GAAoE,CAAC,OAAY,KAAA;AAC5F,EAAA,MAAM,EAAE,UAAA,EAAe,GAAA,mBAAA,CAAoB,OAAO,CAAA;AAElD,EAAO,OAAA;AAAA,IACL,UAAA,EAAY,UAAW,CAAA,MAAA,CAAO,qBAAqB;AAAA,GACrD;AACF;AAGa,MAAA,4BAAA,GAA+B,CAAa,OAGK,KAAA;AAC5D,EAAA,MAAM,EAAE,UAAA,EAAe,GAAA,mBAAA,CAAoB,OAAO,CAAA;AAClD,EAAM,MAAA,mBAAA,GAAsB,UAAW,CAAA,MAAA,CAAO,0BAA0B,CAAA;AAExE,EAAO,OAAA;AAAA,IACL,UAAY,EAAA;AAAA,GACd;AACF;;;;"}