{"version":3,"file":"EchoSrv.mjs","sources":["../../../src/services/EchoSrv.ts"],"sourcesContent":["/**\n * Describes a size with width/height\n *\n * @public\n */\nexport interface SizeMeta {\n  width: number;\n  height: number;\n}\n\n/**\n * Describes the meta information that are sent together with each event.\n *\n * @public\n */\nexport interface EchoMeta {\n  screenSize: SizeMeta;\n  windowSize: SizeMeta;\n  userAgent: string;\n  url?: string;\n  path?: string;\n  /**\n   * A unique browser session\n   */\n  sessionId: string;\n  /**\n   * The current user's username used to login into Grafana e.g. email.\n   */\n  userLogin: string;\n  /**\n   * The current user's unique identifier.\n   */\n  userId: number;\n  /**\n   * True when user is logged in into Grafana.\n   */\n  userSignedIn: boolean;\n  /**\n   * Current user's role\n   */\n  orgRole: string | '';\n  /**\n   * Current user's org\n   */\n  orgId: number;\n  /**\n   * A millisecond epoch\n   */\n  ts: number;\n  /**\n   * A highres timestamp since navigation start\n   */\n  timeSinceNavigationStart: number;\n}\n\n/**\n * Describes echo backends that can be registered to receive of events.\n *\n * @public\n */\nexport interface EchoBackend<T extends EchoEvent = any, O = any> {\n  options: O;\n  supportedEvents: EchoEventType[];\n  flush: () => void;\n  addEvent: (event: T) => void;\n}\n\n/**\n * Describes an echo event.\n *\n * @public\n */\nexport interface EchoEvent<T extends EchoEventType = any, P = any> {\n  type: EchoEventType;\n  /**\n   * Event payload containing event specific data.\n   */\n  payload: P;\n  meta: EchoMeta;\n}\n\n/**\n * Supported echo event types that can be sent via the {@link EchoSrv}.\n *\n * @public\n */\nexport enum EchoEventType {\n  Performance = 'performance',\n  MetaAnalytics = 'meta-analytics',\n  Pageview = 'pageview',\n  Interaction = 'interaction',\n  ExperimentView = 'experimentview',\n  GrafanaJavascriptAgent = 'grafana-javascript-agent',\n}\n\n/**\n * Used to send events to all the registered backends. This should be accessed via the\n * {@link getEchoSrv} function. Will, by default, flush events to the backends every\n * 10s or when the flush function is triggered.\n *\n * @public\n */\nexport interface EchoSrv {\n  /**\n   * Call this to flush current events to the echo backends.\n   */\n  flush(): void;\n  /**\n   * Add a new echo backend to the list of backends that will receive events.\n   */\n  addBackend(backend: EchoBackend): void;\n  /**\n   * Call this to add event that will be sent to the echo backends upon next\n   * flush.\n   *\n   * @param event - Object containing event information.\n   * @param meta - Object that will extend/override the default meta object.\n   */\n  addEvent<T extends EchoEvent>(event: Omit<T, 'meta'>, meta?: {}): void;\n}\n\nlet singletonInstance: EchoSrv;\n\n/**\n * Used during startup by Grafana to set the EchoSrv so it is available\n * via the {@link getEchoSrv} to the rest of the application.\n *\n * @internal\n */\nexport function setEchoSrv(instance: EchoSrv) {\n  // Check if there were any events reported to the FakeEchoSrv (before the main EchoSrv was initialized), and track them\n  if (singletonInstance instanceof FakeEchoSrv) {\n    for (const item of singletonInstance.buffer) {\n      instance.addEvent(item.event, item.meta);\n    }\n  }\n\n  singletonInstance = instance;\n}\n\n/**\n * Used to retrieve the {@link EchoSrv} that can be used to report events to registered\n * echo backends.\n *\n * @public\n */\nexport function getEchoSrv(): EchoSrv {\n  if (!singletonInstance) {\n    singletonInstance = new FakeEchoSrv();\n  }\n\n  return singletonInstance;\n}\n\n/**\n * Used to register echo backends that will receive Grafana echo events during application\n * runtime.\n *\n * @public\n */\nexport const registerEchoBackend = (backend: EchoBackend) => {\n  getEchoSrv().addBackend(backend);\n};\n\nexport class FakeEchoSrv implements EchoSrv {\n  buffer: Array<{ event: Omit<EchoEvent, 'meta'>; meta?: {} | undefined }> = [];\n\n  flush(): void {\n    this.buffer = [];\n  }\n\n  addBackend(backend: EchoBackend): void {}\n\n  addEvent<T extends EchoEvent>(event: Omit<T, 'meta'>, meta?: {} | undefined): void {\n    this.buffer.push({ event, meta });\n  }\n}\n"],"names":["EchoEventType"],"mappings":"AAsFY,IAAA,aAAA,qBAAAA,cAAL,KAAA;AACL,EAAAA,eAAA,aAAc,CAAA,GAAA,aAAA;AACd,EAAAA,eAAA,eAAgB,CAAA,GAAA,gBAAA;AAChB,EAAAA,eAAA,UAAW,CAAA,GAAA,UAAA;AACX,EAAAA,eAAA,aAAc,CAAA,GAAA,aAAA;AACd,EAAAA,eAAA,gBAAiB,CAAA,GAAA,gBAAA;AACjB,EAAAA,eAAA,wBAAyB,CAAA,GAAA,0BAAA;AANf,EAAAA,OAAAA,cAAAA;AAAA,CAAA,EAAA,aAAA,IAAA,EAAA;AAmCZ,IAAI,iBAAA;AAQG,SAAS,WAAW,QAAmB,EAAA;AAE5C,EAAA,IAAI,6BAA6B,WAAa,EAAA;AAC5C,IAAW,KAAA,MAAA,IAAA,IAAQ,kBAAkB,MAAQ,EAAA;AAC3C,MAAA,QAAA,CAAS,QAAS,CAAA,IAAA,CAAK,KAAO,EAAA,IAAA,CAAK,IAAI,CAAA;AAAA;AACzC;AAGF,EAAoB,iBAAA,GAAA,QAAA;AACtB;AAQO,SAAS,UAAsB,GAAA;AACpC,EAAA,IAAI,CAAC,iBAAmB,EAAA;AACtB,IAAA,iBAAA,GAAoB,IAAI,WAAY,EAAA;AAAA;AAGtC,EAAO,OAAA,iBAAA;AACT;AAQa,MAAA,mBAAA,GAAsB,CAAC,OAAyB,KAAA;AAC3D,EAAW,UAAA,EAAA,CAAE,WAAW,OAAO,CAAA;AACjC;AAEO,MAAM,WAA+B,CAAA;AAAA,EAArC,WAAA,GAAA;AACL,IAAA,IAAA,CAAA,MAAA,GAA2E,EAAC;AAAA;AAAA,EAE5E,KAAc,GAAA;AACZ,IAAA,IAAA,CAAK,SAAS,EAAC;AAAA;AACjB,EAEA,WAAW,OAA4B,EAAA;AAAA;AAAC,EAExC,QAAA,CAA8B,OAAwB,IAA6B,EAAA;AACjF,IAAA,IAAA,CAAK,MAAO,CAAA,IAAA,CAAK,EAAE,KAAA,EAAO,MAAM,CAAA;AAAA;AAEpC;;;;"}