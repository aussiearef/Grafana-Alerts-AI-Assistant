{"version":3,"file":"useOptions.mjs","sources":["../../../../src/components/Combobox/useOptions.ts"],"sourcesContent":["import { debounce } from 'lodash';\nimport { useState, useCallback, useMemo } from 'react';\n\nimport { t } from '../../utils/i18n';\n\nimport { fuzzyFind, itemToString } from './filter';\nimport { ComboboxOption } from './types';\nimport { StaleResultError, useLatestAsyncCall } from './useLatestAsyncCall';\n\ntype AsyncOptions<T extends string | number> =\n  | Array<ComboboxOption<T>>\n  | ((inputValue: string) => Promise<Array<ComboboxOption<T>>>);\n\nconst asyncNoop = () => Promise.resolve([]);\n\n/**\n * Abstracts away sync/async options for MultiCombobox (and later Combobox).\n * It also filters options based on the user's input.\n *\n * Returns:\n *  - options either filtered by user's input, or from async options fn\n *  - function to call when user types (to filter, or call async fn)\n *  - loading and error states\n */\nexport function useOptions<T extends string | number>(rawOptions: AsyncOptions<T>, createCustomValue: boolean) {\n  const isAsync = typeof rawOptions === 'function';\n\n  const loadOptions = useLatestAsyncCall(isAsync ? rawOptions : asyncNoop);\n\n  const debouncedLoadOptions = useMemo(\n    () =>\n      debounce((searchTerm: string) => {\n        return loadOptions(searchTerm)\n          .then((options) => {\n            setAsyncOptions(options);\n            setAsyncLoading(false);\n            setAsyncError(false);\n          })\n          .catch((error) => {\n            if (!(error instanceof StaleResultError)) {\n              setAsyncError(true);\n              setAsyncLoading(false);\n\n              if (error) {\n                console.error('Error loading async options for Combobox', error);\n              }\n            }\n          });\n      }, 200),\n    [loadOptions]\n  );\n\n  const [asyncOptions, setAsyncOptions] = useState<Array<ComboboxOption<T>>>([]);\n  const [asyncLoading, setAsyncLoading] = useState(false);\n  const [asyncError, setAsyncError] = useState(false);\n\n  // This hook keeps its own inputValue state (rather than accepting it as an arg) because it needs to be\n  // told it for async options loading anyway.\n  const [userTypedSearch, setUserTypedSearch] = useState('');\n\n  const addCustomValue = useCallback(\n    (opts: Array<ComboboxOption<T>>) => {\n      let currentOptions: Array<ComboboxOption<T>> = opts;\n      if (createCustomValue && userTypedSearch) {\n        //Since the label of a normal option does not have to match its value and a custom option has the same value and label,\n        //we just focus on the value to check if the option already exists\n        const customValueExists = opts.some((opt) => opt.value === userTypedSearch);\n        if (!customValueExists) {\n          currentOptions = [\n            {\n              label: userTypedSearch,\n              value: userTypedSearch as T,\n              description: t('combobox.custom-value.description', 'Use custom value'),\n            },\n            ...currentOptions,\n          ];\n        }\n      }\n      return currentOptions;\n    },\n    [createCustomValue, userTypedSearch]\n  );\n\n  const updateOptions = useCallback(\n    (inputValue: string) => {\n      setUserTypedSearch(inputValue);\n      if (isAsync) {\n        setAsyncLoading(true);\n        debouncedLoadOptions(inputValue);\n      }\n    },\n    [debouncedLoadOptions, isAsync]\n  );\n\n  const organizeOptionsByGroup = useCallback((options: Array<ComboboxOption<T>>) => {\n    const groupedOptions = new Map<string | undefined, Array<ComboboxOption<T>>>();\n    for (const option of options) {\n      const groupExists = groupedOptions.has(option.group);\n      if (groupExists) {\n        groupedOptions.get(option.group)?.push(option);\n      } else {\n        groupedOptions.set(option.group, [option]);\n      }\n    }\n\n    // Reorganize options to have groups first, then undefined group\n    const reorganizeOptions = [];\n    for (const [group, groupOptions] of groupedOptions) {\n      if (!group) {\n        continue;\n      }\n      reorganizeOptions.push(...groupOptions);\n    }\n\n    const undefinedGroupOptions = groupedOptions.get(undefined);\n    if (undefinedGroupOptions) {\n      reorganizeOptions.push(...undefinedGroupOptions);\n    }\n    return reorganizeOptions;\n  }, []);\n\n  const stringifiedOptions = useMemo(() => {\n    return isAsync ? [] : rawOptions.map(itemToString);\n  }, [isAsync, rawOptions]);\n\n  const finalOptions = useMemo(() => {\n    const currentOptions = isAsync ? asyncOptions : fuzzyFind(rawOptions, stringifiedOptions, userTypedSearch);\n    const currentOptionsOrganised = organizeOptionsByGroup(currentOptions);\n\n    return addCustomValue(currentOptionsOrganised);\n  }, [isAsync, organizeOptionsByGroup, addCustomValue, asyncOptions, rawOptions, userTypedSearch, stringifiedOptions]);\n\n  return { options: finalOptions, updateOptions, asyncLoading, asyncError };\n}\n"],"names":[],"mappings":"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"}