import React from 'react';
import { LiveChannelScope, isLiveChannelMessageEvent } from '@grafana/data';
import { getGrafanaLiveSrv } from '@grafana/runtime';
import { Client } from '@modelcontextprotocol/sdk/client/index';
export { Client } from '@modelcontextprotocol/sdk/client/index';
import { JSONRPCMessageSchema } from '@modelcontextprotocol/sdk/types';
import { filter } from 'rxjs';
import { v4 } from 'uuid';
import { LLM_PLUGIN_ID } from './constants.js';

const MCP_GRAFANA_PATH = "mcp/grafana";
class GrafanaLiveTransport {
  constructor(path) {
    this._grafanaLiveSrv = getGrafanaLiveSrv();
    if (path === undefined) {
      const pathId = v4();
      path = `${MCP_GRAFANA_PATH}/${pathId}`;
    }
    this._subscribeChannel = {
      scope: LiveChannelScope.Plugin,
      namespace: LLM_PLUGIN_ID,
      path: `${path}/subscribe`
    };
    this._publishChannel = {
      scope: LiveChannelScope.Plugin,
      namespace: LLM_PLUGIN_ID,
      path: `${path}/publish`
    };
  }
  async start() {
    if (this._stream !== undefined) {
      throw new Error(
        "GrafanaLiveTransport already started! If using Client class, note that connect() calls start() automatically."
      );
    }
    const stream = this._grafanaLiveSrv.getStream(this._subscribeChannel).pipe(filter((event) => isLiveChannelMessageEvent(event)));
    this._stream = stream;
    stream.subscribe((event) => {
      let message;
      try {
        message = JSONRPCMessageSchema.parse(event.message);
      } catch (error) {
        this.onerror?.(error);
        return;
      }
      this.onmessage?.(message);
    });
  }
  async send(message) {
    if (this._stream === undefined) {
      throw new Error("not connected");
    }
    const hasPublishOptions = this._grafanaLiveSrv.publish?.length >= 3;
    if (hasPublishOptions) {
      const options = { useSocket: true };
      return this._grafanaLiveSrv.publish(this._publishChannel, message, options);
    }
    const centrifugeSubscription = (
      // @ts-expect-error
      this._grafanaLiveSrv.deps?.centrifugeSrv?.getChannel?.(
        this._publishChannel
      )?.subscription
    );
    if (centrifugeSubscription) {
      return centrifugeSubscription.publish(message);
    }
    console.warn(
      "Websocket subscription not available, falling back to HTTP publish. This may fail in HA setups. If you see this, please create an issue at https://github.com/grafana/grafana-llm-app/issues/new."
    );
    await this._grafanaLiveSrv.publish(this._publishChannel, message);
  }
  async close() {
    this._stream = undefined;
  }
}
const clientMap = /* @__PURE__ */ new Map();
const MCPClientContext = React.createContext(null);
function clientKey(appName, appVersion) {
  return `${appName}-${appVersion}`;
}
function createClientResource(appName, appVersion) {
  let status = "pending";
  let result = null;
  let error = null;
  const key = clientKey(appName, appVersion);
  const promise = (async () => {
    if (clientMap.has(key)) {
      result = clientMap.get(key);
      status = "success";
      return result;
    }
    try {
      const client = new Client({
        name: appName,
        version: appVersion
      });
      const transport = new GrafanaLiveTransport();
      await client.connect(transport);
      clientMap.set(key, client);
      status = "success";
      result = client;
      return client;
    } catch (e) {
      status = "error";
      error = e;
      throw e;
    }
  })();
  return {
    read() {
      if (status === "pending") {
        throw promise;
      } else if (status === "error") {
        throw error;
      } else if (status === "success" && result) {
        return result;
      }
      throw new Error("Unexpected resource state");
    }
  };
}
function MCPClientProvider({
  appName,
  appVersion,
  children
}) {
  const resource = createClientResource(appName, appVersion);
  const client = resource.read();
  React.useEffect(() => {
    return () => {
      if (client) {
        client.close();
      }
      clientMap.delete(clientKey(appName, appVersion));
    };
  }, [client, appName, appVersion]);
  return /* @__PURE__ */ React.createElement(MCPClientContext.Provider, { value: client }, children);
}
function useMCPClient() {
  const client = React.useContext(MCPClientContext);
  if (client === null) {
    throw new Error("useMCPClient must be used within an MCPClientProvider");
  }
  return client;
}
function convertToolsToOpenAI(tools) {
  return tools.map(convertToolToOpenAI);
}
function convertToolToOpenAI(tool) {
  return {
    type: "function",
    function: {
      name: tool.name,
      description: tool.description,
      parameters: tool.inputSchema.properties !== undefined ? tool.inputSchema : undefined
    }
  };
}

export { GrafanaLiveTransport, MCPClientProvider, convertToolsToOpenAI, useMCPClient };
//# sourceMappingURL=mcp.js.map
