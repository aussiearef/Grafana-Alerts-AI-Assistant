{"version":3,"file":"mcp.js","sources":["../../src/mcp.tsx"],"sourcesContent":["import React from 'react';\n\nimport { isLiveChannelMessageEvent, LiveChannelAddress, LiveChannelMessageEvent, LiveChannelScope } from '@grafana/data';\nimport { getGrafanaLiveSrv, GrafanaLiveSrv } from '@grafana/runtime';\nimport { Transport } from '@modelcontextprotocol/sdk/shared/transport';\nimport { Client } from '@modelcontextprotocol/sdk/client/index';\nimport { JSONRPCMessage, JSONRPCMessageSchema, Tool as MCPTool } from '@modelcontextprotocol/sdk/types';\nimport { Observable, filter } from 'rxjs';\nimport { v4 as uuid } from 'uuid';\n\nimport { LLM_PLUGIN_ID } from './constants';\nimport { Tool as OpenAITool } from './openai';\n\nconst MCP_GRAFANA_PATH = 'mcp/grafana'\n\n/**\n * An MCP transport which uses the Grafana LLM plugin's built-in MCP server,\n * over Grafana Live.\n *\n * Use this with a client from `@modelcontextprotocol/sdk`.\n *\n * @experimental\n */\nexport class GrafanaLiveTransport implements Transport {\n  _grafanaLiveSrv: GrafanaLiveSrv = getGrafanaLiveSrv()\n\n  /**\n   * The Grafana Live channel used by this transport.\n   */\n  _subscribeChannel: LiveChannelAddress;\n\n  /**\n   * The Grafana Live channel used by this transport.\n   */\n  _publishChannel: LiveChannelAddress;\n\n  /**\n   * The Grafana Live stream over which MCP messages are received.\n   */\n  _stream?: Observable<LiveChannelMessageEvent<unknown>>;\n\n  // Methods defined as part of the Transport interface.\n  // These will be attached by the client.\n  onclose?: (() => void) | undefined;\n  onerror?: ((error: Error) => void) | undefined;\n  onmessage?: ((message: JSONRPCMessage) => void) | undefined;\n\n  constructor(path?: string) {\n    if (path === undefined) {\n      // Construct a unique path for this transport.\n      const pathId = uuid();\n      path = `${MCP_GRAFANA_PATH}/${pathId}`;\n    }\n    this._subscribeChannel = {\n      scope: LiveChannelScope.Plugin,\n      namespace: LLM_PLUGIN_ID,\n      path: `${path}/subscribe`,\n    };\n    this._publishChannel = {\n      scope: LiveChannelScope.Plugin,\n      namespace: LLM_PLUGIN_ID,\n      path: `${path}/publish`,\n    };\n  }\n\n  async start(): Promise<void> {\n    if (this._stream !== undefined) {\n      throw new Error(\n        \"GrafanaLiveTransport already started! If using Client class, note that connect() calls start() automatically.\"\n      );\n    }\n\n    const stream = this._grafanaLiveSrv.getStream(this._subscribeChannel)\n      .pipe(filter((event) => isLiveChannelMessageEvent(event)));\n    this._stream = stream;\n    stream.subscribe((event) => {\n      let message: JSONRPCMessage;\n      try {\n        message = JSONRPCMessageSchema.parse(event.message);\n      } catch (error) {\n        this.onerror?.(error as Error)\n        return;\n      }\n      this.onmessage?.(message);\n    });\n  }\n\n  async send(message: JSONRPCMessage): Promise<void> {\n    if (this._stream === undefined) {\n      throw new Error(\"not connected\");\n    }\n\n    // The Grafana Live service API for publishing messages sends a message\n    // to Grafana's HTTP API rather than over the live channel, for reasons\n    // that are unclear (but presumably justified in the default case).\n    // This is fine when there is only one Grafana instance, but when there\n    // are multiple (e.g. in a HA setup), the HTTP request will be routed\n    // to a random Grafana instance, while we need it to be routed to the\n    // same instance that the client is connected to (since there is a\n    // long-lived stream over the live channel).\n    //\n    // We can use the `useSocket` argument when trying to publish to the\n    // live channel to force the use of the Websocket instead of the HTTP API.\n    // This will work in both single-instance and HA setups. However, it's only\n    // available in Grafana 11.6.0 and later. We can check for this by checking\n    // if the `publish` method has a third argument, which is the `options`\n    // argument.\n    const hasPublishOptions = this._grafanaLiveSrv.publish?.length >= 3;\n    if (hasPublishOptions) {\n      // TODO: use `LivePublishOptions` from `@grafana/runtime` once\n      // Grafana 11.6.0 is released. We can remove these `@ts-expect-error`\n      // comments once that happens.\n      //@ts-expect-error\n      const options: LivePublishOptions = { useSocket: true };\n      //@ts-expect-error\n      return this._grafanaLiveSrv.publish(this._publishChannel, message, options);\n    }\n\n    // If that option isn't available, we can first fall back to trying to\n    // drilling down into the implementation details of the Grafana Live\n    // service and using the Centrifuge API directly to publish the message\n    // to the same stream that the client is connected to.\n    // Realistically this should work in all versions of Grafana older than\n    // 9, which is much further back than this plugin even supports, so should\n    // always work.\n    const centrifugeSubscription =\n      // @ts-expect-error\n      this._grafanaLiveSrv.deps?.centrifugeSrv?.getChannel?.(\n        this._publishChannel,\n      )?.subscription;\n    if (centrifugeSubscription) {\n      return centrifugeSubscription.publish(message);\n    }\n\n    // If the centrifuge subscription is still not available for some reason,\n    // fall back to the official HTTP publish method. This won't work in HA\n    // setups but it's better than nothing.\n    console.warn(\n      \"Websocket subscription not available, falling back to HTTP publish. \" +\n      \"This may fail in HA setups. If you see this, please create an issue at \" +\n      \"https://github.com/grafana/grafana-llm-app/issues/new.\"\n    );\n    await this._grafanaLiveSrv.publish(this._publishChannel, message);\n  }\n\n  async close(): Promise<void> {\n    this._stream = undefined;\n  }\n}\n\n// Create a map to store client instances. These will be keyed by the appName and appVersion.\n// This effectively means:\n// - each app will have a single client instance that is reused across the application.\n// - since clients are stored outside of the MCPClientProvider component, they will be\n//   cleaned up when the component unmounts.\n// - this also allows users to wrap the MCPClientProvider in Suspense, which will\n//   automatically suspend the component until the client is ready.\nconst clientMap = new Map<string, Client>();\n\n// Context holding a client instance.\nconst MCPClientContext = React.createContext<Client | null>(null);\n\n// Create a key for the client map.\nfunction clientKey(appName: string, appVersion: string) {\n  return `${appName}-${appVersion}`;\n}\n\n// A resource type, used with `createClientResource` to fetch the client or\n// throw a promise if it's not yet ready.\ntype ClientResource = {\n  read: () => Client;\n};\n\n// Create a resource that works with Suspense.\nfunction createClientResource(appName: string, appVersion: string): ClientResource {\n  let status: 'pending' | 'success' | 'error' = 'pending';\n  let result: Client | null = null;\n  let error: Error | null = null;\n\n  const key = clientKey(appName, appVersion);\n  const promise = (async () => {\n    if (clientMap.has(key)) {\n      result = clientMap.get(key)!;\n      status = 'success';\n      return result;\n    }\n\n    try {\n      const client = new Client({\n        name: appName,\n        version: appVersion,\n      });\n      const transport = new GrafanaLiveTransport();\n      await client.connect(transport);\n      clientMap.set(key, client);\n      status = 'success';\n      result = client;\n      return client;\n    } catch (e) {\n      status = 'error';\n      error = e as Error;\n      throw e;\n    }\n  })();\n\n  return {\n    read() {\n      if (status === 'pending') {\n        throw promise;\n      } else if (status === 'error') {\n        throw error;\n      } else if (status === 'success' && result) {\n        return result;\n      }\n      throw new Error('Unexpected resource state');\n    },\n  };\n}\n\ninterface MCPClientProviderProps {\n  appName: string;\n  appVersion: string;\n  children: React.ReactNode;\n}\n\n/**\n * MCPClientProvider is a React context provider that creates an MCP client\n * and manages its lifecycle.\n *\n * It should be used to wrap the entire application in a single provider.\n * This ensures that the client is created once and reused across the application.\n *\n * It also supports Suspense, which will suspend the component until the client\n * is ready. This allows you to use the client in components that are not yet\n * ready, such as those that are loading data.\n *\n * Example usage:\n * ```tsx\n * <Suspense fallback={<LoadingPlaceholder />}>\n *   <ErrorBoundary>\n *     {({ error }) => {\n *       if (error) {\n *         return <div>Something went wrong: {error.message}</div>;\n *       }\n *       return (\n *         <MCPClientProvider appName=\"MyApp\" appVersion=\"1.0.0\">\n *           <YourComponent />\n *         </MCPClientProvider>\n *       );\n *     }}\n *   </ErrorBoundary>\n * </Suspense>\n * ```\n *\n * @experimental\n */\nexport function MCPClientProvider({\n  appName,\n  appVersion,\n  children,\n}: MCPClientProviderProps) {\n  const resource = createClientResource(appName, appVersion);\n\n  // This will either return the client or throw a promise/error.\n  // If it throws a promise, Suspense will suspend the component until it resolves.\n  // If it throws an error, it should be caught by an ErrorBoundary.\n  const client = resource.read();\n\n  // Cleanup when the component unmounts.\n  React.useEffect(() => {\n    return () => {\n      if (client) {\n        client.close();\n      }\n      clientMap.delete(clientKey(appName, appVersion));\n    };\n  }, [client, appName, appVersion]);\n\n  return (\n    <MCPClientContext.Provider value={client}>\n      {children}\n    </MCPClientContext.Provider>\n  );\n}\n\n/**\n * Convenience hook to use an MCP client from a component.\n *\n * This hook should be used within an `MCPClientProvider`.\n *\n * @experimental\n */\nexport function useMCPClient(): Client {\n  const client = React.useContext(MCPClientContext);\n  if (client === null) {\n    throw new Error('useMCPClient must be used within an MCPClientProvider');\n  }\n  return client;\n}\n\n/**\n * Re-export of the Client class from the MCP SDK.\n *\n * @experimental\n */\nexport { Client };\n\n/**\n * Convert an array of MCP tools to an array of OpenAI tools.\n *\n * This is useful when you want to use the MCP client with the LLM plugin's\n * `chatCompletions` or `streamChatCompletions` functions.\n *\n * @experimental\n */\nexport function convertToolsToOpenAI(tools: MCPTool[]): OpenAITool[] {\n  return tools.map(convertToolToOpenAI);\n}\n\nfunction convertToolToOpenAI(tool: MCPTool): OpenAITool {\n  return {\n    type: 'function',\n    function: {\n      name: tool.name,\n      description: tool.description,\n      parameters: tool.inputSchema.properties !== undefined ? tool.inputSchema : undefined,\n    },\n  };\n}\n"],"names":["uuid"],"mappings":"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"}